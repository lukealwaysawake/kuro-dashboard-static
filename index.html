<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Kuro Trading Dashboard</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg: #0a0a0c;
      --bg2: #111114;
      --border: #222228;
      --text: #e4e4e7;
      --muted: #71717a;
      --green: #22c55e;
      --red: #ef4444;
      --blue: #3b82f6;
    }
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body { 
      font-family: 'JetBrains Mono', monospace; 
      background: var(--bg); 
      color: var(--text); 
      font-size: 13px;
      line-height: 1.4;
    }
    .container { max-width: 1600px; margin: 0 auto; padding: 16px; }
    @media (max-width: 600px) { .container { padding: 10px; } }
    
    /* Header */
    .header { 
      display: flex; 
      justify-content: space-between; 
      align-items: center; 
      padding: 12px 0; 
      border-bottom: 1px solid var(--border);
      margin-bottom: 16px;
    }
    .title { font-size: 16px; font-weight: 600; }
    .status { color: var(--green); font-size: 12px; }
    .status::before { content: 'â—'; margin-right: 6px; }
    @media (max-width: 600px) {
      .header { flex-wrap: wrap; gap: 8px; }
      .title { font-size: 14px; }
    }
    
    /* Stats Bar */
    .stats-bar {
      display: flex;
      gap: 16px 24px;
      padding: 12px 16px;
      background: var(--bg2);
      border: 1px solid var(--border);
      border-radius: 6px;
      margin-bottom: 16px;
      flex-wrap: wrap;
    }
    .stat { display: flex; gap: 6px; align-items: center; }
    .stat-label { color: var(--muted); font-size: 11px; }
    .stat-value { font-weight: 500; }
    .stat-value.green { color: var(--green); }
    .stat-value.red { color: var(--red); }
    .stat-sep { width: 1px; height: 16px; background: var(--border); }
    @media (max-width: 600px) {
      .stats-bar { gap: 8px 16px; padding: 10px 12px; font-size: 11px; }
      .stat-sep { display: none; }
      .stat-ml-auto { margin-left: 0 !important; }
    }
    
    /* Section */
    .section { margin-bottom: 24px; }
    .section-title { 
      font-size: 14px; 
      font-weight: 600; 
      margin-bottom: 12px;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }
    
    /* Table */
    .table-wrap { 
      overflow-x: auto; 
      border: 1px solid var(--border);
      border-radius: 6px;
    }
    table { 
      width: 100%; 
      border-collapse: collapse; 
      white-space: nowrap;
    }
    th {
      text-align: left;
      padding: 8px 10px;
      background: var(--bg2);
      color: var(--muted);
      font-weight: 500;
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      border-bottom: 1px solid var(--border);
      position: sticky;
      top: 0;
    }
    th.right, td.right { text-align: right; }
    th.center, td.center { text-align: center; }
    td {
      padding: 8px 10px;
      border-bottom: 1px solid var(--border);
    }
    @media (max-width: 600px) {
      th, td { padding: 6px 6px; font-size: 11px; }
    }
    tr:hover { background: rgba(255,255,255,0.02); }
    tr:last-child td { border-bottom: none; }
    
    /* Badge */
    .badge {
      display: inline-block;
      padding: 2px 6px;
      border-radius: 3px;
      font-size: 11px;
      font-weight: 500;
    }
    .badge-long { background: rgba(34,197,94,0.15); color: var(--green); }
    .badge-short { background: rgba(239,68,68,0.15); color: var(--red); }
    .badge-neutral { background: rgba(113,113,122,0.15); color: var(--muted); }
    
    /* Values */
    .green { color: var(--green); }
    .red { color: var(--red); }
    .muted { color: var(--muted); }
    
    /* Ratio Bar */
    .ratio-bar {
      width: 60px;
      height: 6px;
      background: rgba(239,68,68,0.3);
      border-radius: 3px;
      overflow: hidden;
      display: inline-block;
      vertical-align: middle;
    }
    .ratio-fill {
      height: 100%;
      background: var(--green);
    }
    .ratio-text {
      font-size: 11px;
      color: var(--muted);
      margin-left: 6px;
    }
    
    /* My Position Card */
    .my-position {
      background: var(--bg2);
      border: 1px solid var(--green);
      border-radius: 6px;
      padding: 16px;
      margin-bottom: 16px;
    }
    .my-position.empty {
      border-color: var(--border);
      text-align: center;
      color: var(--muted);
      padding: 32px;
    }
    .pos-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
    }
    .pos-row:last-child { margin-bottom: 0; }
    .pos-coin { font-size: 16px; font-weight: 600; }
    .pos-pnl { font-size: 18px; font-weight: 600; }
    .pos-meta { font-size: 12px; color: var(--muted); }
    
    /* Grid */
    .grid-2 { display: grid; grid-template-columns: 1fr 1fr; gap: 16px; }
    .grid-3 { display: grid; grid-template-columns: 1fr 1.5fr 1fr; gap: 16px; }
    @media (max-width: 900px) { .grid-2, .grid-3 { grid-template-columns: 1fr; gap: 12px; } }
    
    /* Decision */
    .decision {
      background: var(--bg2);
      border: 1px solid var(--border);
      border-radius: 6px;
      padding: 16px;
    }
    .decision-action {
      font-size: 16px;
      font-weight: 600;
      margin-bottom: 12px;
    }
    .decision-reason {
      font-size: 12px;
      color: var(--muted);
      line-height: 1.6;
    }
    .decision-scores {
      display: flex;
      gap: 12px;
      margin-top: 12px;
      padding-top: 12px;
      border-top: 1px solid var(--border);
      flex-wrap: wrap;
    }
    .score-item { font-size: 12px; }
    .score-label { color: var(--muted); }
    @media (max-width: 600px) {
      .decision-action { font-size: 14px; }
      .decision-reason { font-size: 11px; }
      .decision-scores { gap: 8px; }
      .score-item { font-size: 11px; }
    }
    
    /* Refresh */
    .refresh-btn {
      background: var(--bg2);
      border: 1px solid var(--border);
      color: var(--text);
      padding: 6px 12px;
      border-radius: 4px;
      cursor: pointer;
      font-family: inherit;
      font-size: 12px;
    }
    .refresh-btn:hover { background: var(--border); }

    /* Timeline */
    .timeline { }
    .tl-entry {
      display: flex;
      gap: 10px;
      padding: 8px 0;
      position: relative;
    }
    .tl-entry + .tl-entry { border-top: 1px solid rgba(255,255,255,0.04); }
    .tl-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      margin-top: 4px;
      flex-shrink: 0;
    }
    .tl-dot.ENTRY { background: var(--green); }
    .tl-dot.EXIT { background: var(--red); }
    .tl-dot.FLIP { background: var(--blue); }
    .tl-dot.PERIODIC { background: var(--muted); }
    .tl-dot.SKIP { background: #f59e0b; }
    .tl-dot.CURRENT { background: var(--blue); }
    .tl-dot.SYSTEM { background: #a78bfa; }
    .tl-body { flex: 1; min-width: 0; }
    .tl-head {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
    }
    .tl-action { font-size: 12px; font-weight: 500; }
    .tl-time { font-size: 11px; color: var(--muted); flex-shrink: 0; }
    .tl-reason { font-size: 11px; color: var(--muted); margin-top: 2px; line-height: 1.5; white-space: pre-line; }
    .tl-pnl { font-size: 11px; font-weight: 500; margin-left: 6px; }
    .tl-detail {
      margin-top: 6px;
      padding: 8px 10px;
      background: rgba(255,255,255,0.02);
      border: 1px solid var(--border);
      border-radius: 4px;
      font-size: 11px;
      color: var(--muted);
      line-height: 1.6;
      display: none;
    }
    .tl-detail.open { display: block; }
    .tl-detail-row { display: flex; justify-content: space-between; gap: 8px; }
    .tl-detail-label { color: var(--muted); }
    .tl-detail-sep { border-top: 1px solid var(--border); margin: 4px 0; }
    .tl-toggle {
      background: none; border: none; color: var(--muted);
      font-size: 10px; cursor: pointer; padding: 2px 4px;
      font-family: inherit; border-radius: 3px;
    }
    .tl-toggle:hover { color: var(--text); background: rgba(255,255,255,0.05); }

    /* Chart */
    .chart-section {
      background: var(--bg2);
      border: 1px solid var(--border);
      border-radius: 6px;
      padding: 16px;
      margin-bottom: 24px;
    }
    .chart-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 12px;
    }
    .chart-title {
      font-size: 12px;
      font-weight: 600;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }
    /* Page Tabs */
    .page-tabs { display: flex; gap: 4px; }
    .page-tab {
      background: transparent; border: 1px solid var(--border); color: var(--muted);
      padding: 4px 12px; border-radius: 6px; cursor: pointer; font-size: 12px; font-weight: 500;
    }
    .page-tab.active { background: var(--green); color: #000; border-color: var(--green); }
    .page-tab:hover:not(.active) { color: var(--text); border-color: var(--text); }

    /* Analytics page */
    .analytics-page { display: none; }
    .analytics-page.active { display: block; }
    .profile-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(300px, 1fr)); gap: 12px; margin: 16px 0; }
    .profile-card {
      background: var(--card); border: 1px solid var(--border); border-radius: 12px; padding: 16px;
    }
    .profile-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px; }
    .profile-name { font-size: 16px; font-weight: 700; }
    .profile-badge { font-size: 11px; padding: 2px 8px; border-radius: 4px; }
    .profile-stat { display: flex; justify-content: space-between; padding: 4px 0; border-bottom: 1px solid var(--border); font-size: 13px; }
    .profile-stat:last-child { border: none; }
    .profile-stat .label { color: var(--muted); }
    .profile-stat .value { font-weight: 600; }
    .consensus-chart { background: var(--card); border: 1px solid var(--border); border-radius: 12px; padding: 16px; margin: 16px 0; }
    .heatmap-wrap { background: var(--card); border: 1px solid var(--border); border-radius: 12px; padding: 16px; margin: 16px 0; overflow-x: auto; }
    .heatmap-cell { width: 28px; height: 28px; display: inline-flex; align-items: center; justify-content: center; font-size: 10px; border-radius: 4px; }

    /* Algorithm Page */
    .algo-section { background: var(--card); border: 1px solid var(--border); border-radius: 12px; padding: 20px; margin: 16px 0; }
    .algo-title { font-size: 18px; font-weight: 700; margin-bottom: 12px; }
    .algo-flow { display: flex; flex-wrap: wrap; gap: 12px; justify-content: center; align-items: stretch; margin: 16px 0; }
    .algo-node { background: #1a1d23; border: 2px solid var(--border); border-radius: 12px; padding: 16px; min-width: 160px; max-width: 200px; text-align: center; position: relative; }
    .algo-node.highlight { border-color: var(--green); box-shadow: 0 0 12px rgba(34,197,94,0.2); }
    .algo-node.gate { border-color: #f59e0b; border-style: dashed; }
    .algo-node .node-icon { font-size: 28px; margin-bottom: 6px; }
    .algo-node .node-title { font-size: 13px; font-weight: 700; margin-bottom: 4px; }
    .algo-node .node-desc { font-size: 11px; color: var(--muted); line-height: 1.4; }
    .algo-arrow { display: flex; align-items: center; font-size: 24px; color: var(--muted); }
    .algo-weight-bar { display: flex; align-items: center; gap: 8px; padding: 6px 0; }
    .algo-weight-bar .bar-label { width: 100px; font-size: 12px; color: var(--muted); }
    .algo-weight-bar .bar-fill { height: 20px; border-radius: 4px; display: flex; align-items: center; justify-content: flex-end; padding-right: 6px; font-size: 10px; font-weight: 700; color: #000; }
    .algo-weight-bar .bar-bg { flex: 1; background: #1a1d23; border-radius: 4px; overflow: hidden; }
    .algo-gate-table { width: 100%; border-collapse: collapse; margin: 8px 0; }
    .algo-gate-table td, .algo-gate-table th { padding: 6px 10px; text-align: left; font-size: 12px; border-bottom: 1px solid var(--border); }
    .algo-gate-table th { color: var(--muted); font-weight: 600; }
    .algo-formula { background: #0d0f12; border: 1px solid var(--border); border-radius: 8px; padding: 12px 16px; font-family: 'JetBrains Mono', monospace; font-size: 12px; margin: 8px 0; overflow-x: auto; color: var(--green); }
    @media (max-width: 768px) { .algo-flow { flex-direction: column; align-items: center; } .algo-node { max-width: 100%; } }

    /* Weight Sliders */
    .weight-row { display: flex; align-items: center; gap: 12px; padding: 8px 0; border-bottom: 1px solid var(--border); }
    .weight-row:last-child { border: none; }
    .weight-label { width: 140px; font-size: 12px; font-weight: 600; }
    .weight-meta { width: 100px; font-size: 11px; color: var(--muted); }
    .weight-slider { flex: 1; -webkit-appearance: none; height: 4px; background: var(--border); border-radius: 2px; outline: none; }
    .weight-slider::-webkit-slider-thumb { -webkit-appearance: none; width: 16px; height: 16px; border-radius: 50%; background: var(--green); cursor: pointer; }
    .weight-value { width: 50px; text-align: right; font-size: 13px; font-weight: 700; font-family: monospace; }
    .weight-value.boosted { color: var(--green); }
    .weight-value.nerfed { color: var(--red); }
    .weight-value.neutral { color: var(--muted); }
    .weight-toggle { background: none; border: 1px solid var(--border); color: var(--text); width: 28px; height: 28px; border-radius: 6px; cursor: pointer; font-size: 14px; }
    .weight-toggle.disabled { opacity: 0.3; }

    .chart-tabs {
      display: flex;
      gap: 2px;
      background: var(--bg);
      border-radius: 4px;
      padding: 2px;
    }
    .chart-tab {
      background: none;
      border: none;
      color: var(--muted);
      font-family: inherit;
      font-size: 11px;
      font-weight: 500;
      padding: 4px 10px;
      border-radius: 3px;
      cursor: pointer;
      transition: all 0.15s;
    }
    .chart-tab:hover { color: var(--text); }
    .chart-tab.active {
      background: var(--border);
      color: var(--text);
    }
    .chart-summary {
      display: flex;
      align-items: baseline;
      gap: 12px;
      margin-bottom: 12px;
      flex-wrap: wrap;
    }
    @media (max-width: 600px) {
      .chart-summary {
        gap: 6px 10px;
        font-size: 12px;
      }
      .chart-breakdown {
        flex-basis: 100%;
        margin-left: 0 !important;
        margin-top: 4px;
        font-size: 10px !important;
      }
    }
    .chart-value {
      font-size: 22px;
      font-weight: 600;
    }
    .chart-pnl {
      font-size: 13px;
      font-weight: 500;
    }
    .chart-canvas-wrap {
      position: relative;
      height: 180px;
    }
    .chart-canvas-wrap canvas {
      width: 100% !important;
      height: 100% !important;
    }
    @media (max-width: 600px) {
      .chart-section { padding: 12px; }
      .chart-value { font-size: 18px; }
      .chart-pnl { font-size: 11px; }
      .chart-canvas-wrap { height: 140px; }
      .chart-tab { padding: 3px 8px; font-size: 10px; }
    }

    /* Footer */
    .footer {
      text-align: center;
      padding: 16px;
      color: var(--muted);
      font-size: 11px;
    }
  </style>
</head>
<body>
  <div class="container">
    <!-- Header -->
    <header class="header">
      <div class="title">ğŸ¤– Kuro Trading</div>
      <div style="display:flex;align-items:center;gap:16px;">
        <div class="page-tabs">
          <button class="page-tab active" onclick="switchPage('trading')">ğŸ“Š Trading</button>
          <button class="page-tab" onclick="switchPage('analytics')">ğŸ‹ Whale Analytics</button>
          <button class="page-tab" onclick="switchPage('algorithm')">ğŸ§  Algorithm</button>
        </div>
        <span class="status">Hyperliquid Mainnet</span>
        <button class="refresh-btn" onclick="refresh()">â†» Refresh</button>
      </div>
    </header>

    <!-- Trading Page -->
    <div id="trading-page" class="trading-page active">
    <!-- Stats Bar -->
    <div class="stats-bar">
      <div class="stat">
        <span class="stat-label">Account:</span>
        <span class="stat-value green" id="account-value">$--</span>
      </div>
      <div class="stat">
        <span class="stat-label">Realized:</span>
        <span class="stat-value" id="realized-pnl">--</span>
      </div>
      <div class="stat">
        <span class="stat-label">Unrealized:</span>
        <span class="stat-value" id="total-pnl">--</span>
      </div>
      <div class="stat">
        <span class="stat-label">BTC:</span>
        <span class="stat-value" id="btc-price">$--</span>
      </div>
      <div class="stat">
        <span class="stat-label">ETH:</span>
        <span class="stat-value" id="eth-price">$--</span>
      </div>
      <div class="stat-sep"></div>
      <div class="stat">
        <span class="stat-label">Margin:</span>
        <span class="stat-value" id="margin-info">--</span>
      </div>
      <div class="stat">
        <span class="stat-label">Avail:</span>
        <span class="stat-value green" id="withdrawable">--</span>
      </div>
      <div class="stat">
        <span class="stat-label">Pos:</span>
        <span class="stat-value" id="pos-value">--</span>
      </div>
      <div class="stat">
        <span class="stat-label">Lev:</span>
        <span class="stat-value" id="acct-leverage">--</span>
      </div>
      <div class="stat stat-ml-auto" style="margin-left:auto;">
        <span class="stat-label">Updated:</span>
        <span class="stat-value" id="update-time">--</span>
      </div>
    </div>

    <!-- Portfolio Performance Chart -->
    <div class="chart-section">
      <div class="chart-header">
        <span class="chart-title">Total PnL</span>
        <div class="chart-tabs">
          <button class="chart-tab" data-range="1d" onclick="switchRange('1d')">1D</button>
          <button class="chart-tab active" data-range="7d" onclick="switchRange('7d')">7D</button>
          <button class="chart-tab" data-range="30d" onclick="switchRange('30d')">30D</button>
          <button class="chart-tab" data-range="all" onclick="switchRange('all')">All</button>
        </div>
      </div>
      <div class="chart-summary" id="chart-summary">
        <span class="chart-value" id="chart-value">$--</span>
        <span class="chart-pnl" id="chart-pnl">--</span>
        <span class="chart-breakdown" id="chart-breakdown" style="margin-left:12px;font-size:11px;color:var(--muted);">
          Realized: <span id="chart-realized">--</span> Â· Unrealized: <span id="chart-unrealized">--</span>
        </span>
      </div>
      <div class="chart-canvas-wrap">
        <canvas id="portfolio-chart"></canvas>
      </div>
    </div>

    <!-- Positions -->
    <div class="section">
      <div class="section-title">ğŸ“ˆ Positions</div>
      <div id="my-positions">
        <div class="my-position empty">No positions</div>
      </div>
    </div>

    <!-- Decision + Timeline (50/50) -->
    <div class="grid-2">
      <div class="section">
        <div class="section-title">ğŸ§  Decision</div>
        <div class="decision" id="decision-box">
          <div class="decision-action">â³ Analyzing...</div>
          <div class="decision-reason">Loading...</div>
        </div>
      </div>
      <div class="section">
        <div class="section-title">ğŸ“‹ History</div>
        <div class="timeline" id="decision-history"></div>
      </div>
    </div>

    <!-- Whale Positions Table (í•µì‹¬!) -->
    <div class="section">
      <div class="section-title" style="display:flex;justify-content:space-between;align-items:center;">
        <span>ğŸ‹ Whale Positions by Coin (Aggregate)</span>
        <button class="refresh-btn" id="toggle-whale" onclick="toggleWhaleTable()">Show All</button>
      </div>
      <div class="table-wrap">
        <table id="whale-table">
          <thead>
            <tr>
              <th>Coin</th>
              <th>Direction</th>
              <th class="center">Momentum</th>
              <th class="right">Net Value</th>
              <th class="center">Long / Short</th>
              <th class="right">Avg Long</th>
              <th class="right">Avg Short</th>
              <th class="right">Long PnL</th>
              <th class="right">Short PnL</th>
              <th class="center">L/S Ratio</th>
            </tr>
          </thead>
          <tbody id="whale-tbody">
            <tr><td colspan="11" style="text-align:center;color:var(--muted);padding:24px;">Loading...</td></tr>
          </tbody>
        </table>
      </div>
    </div>

    <!-- Recent Trades -->
    <div class="section">
      <div class="section-title" style="display:flex;justify-content:space-between;align-items:center;">
        <span>âš¡ Recent Whale Trades (24h)</span>
        <button class="refresh-btn" id="toggle-trades" onclick="toggleTrades()" style="display:none;">Show All</button>
      </div>
      <div class="table-wrap">
        <table>
          <thead>
            <tr>
              <th>Time</th>
              <th>Whale</th>
              <th>Coin</th>
              <th>Action</th>
              <th class="right">Size</th>
              <th class="right">Price</th>
              <th class="right">Value</th>
            </tr>
          </thead>
          <tbody id="trades-tbody">
            <tr><td colspan="7" style="text-align:center;color:var(--muted);padding:24px;">Loading...</td></tr>
          </tbody>
        </table>
      </div>
    </div>

    <!-- Consensus Signals -->
    <div class="section">
      <div class="section-title" style="display:flex;justify-content:space-between;align-items:center;">
        <span>ğŸ¯ Consensus Signals (5+ Whales)</span>
        <button class="refresh-btn" id="toggle-signals" onclick="toggleSignals()" style="display:none;">Show All</button>
      </div>
      <div class="table-wrap">
        <table>
          <thead>
            <tr>
              <th>Coin</th>
              <th>Direction</th>
              <th class="center">Whales</th>
              <th class="right">Avg Entry</th>
              <th class="right">Total Value</th>
              <th class="center">L/S Ratio</th>
            </tr>
          </thead>
          <tbody id="signals-tbody">
            <tr><td colspan="6" style="text-align:center;color:var(--muted);padding:24px;">Loading...</td></tr>
          </tbody>
        </table>
      </div>
    </div>

    </div><!-- /trading-page -->

    <!-- Analytics Page -->
    <div id="analytics-page" class="analytics-page">
      <div class="stats-bar" id="analytics-stats">
        <div class="stat-item"><span class="stat-label">Total Trades</span><span class="stat-value" id="a-total-trades">--</span></div>
        <div class="stat-item"><span class="stat-label">Round Trips</span><span class="stat-value" id="a-round-trips">--</span></div>
        <div class="stat-item"><span class="stat-label">Avg Win Rate</span><span class="stat-value green" id="a-avg-wr">--</span></div>
        <div class="stat-item"><span class="stat-label">Whales Tracked</span><span class="stat-value" id="a-whale-count">--</span></div>
      </div>

      <!-- Whale Profiles -->
      <div class="section"><div class="section-title"><span>ğŸ‹ Whale Profiles</span></div></div>
      <div class="profile-grid" id="profile-grid"></div>

      <!-- Consensus History Chart -->
      <div class="consensus-chart">
        <div class="section-title"><span>ğŸ“ˆ BTC/ETH Whale Consensus History</span></div>
        <canvas id="consensus-chart" height="200"></canvas>
      </div>

      <!-- Trading Heatmap -->
      <div class="heatmap-wrap">
        <div class="section-title"><span>ğŸ”¥ Trading Activity Heatmap (by hour KST)</span></div>
        <div id="heatmap-container"></div>
      </div>
      <!-- Weight Adjustment -->
      <div class="consensus-chart" style="margin-top:16px">
        <div class="section-title" style="display:flex;justify-content:space-between;align-items:center">
          <span>âš–ï¸ Whale Weight Adjustment</span>
          <div style="display:flex;gap:8px">
            <button class="refresh-btn" onclick="resetWeights()" style="font-size:11px">Reset All</button>
            <button class="refresh-btn" onclick="applyWeights()" style="background:var(--green);color:#000;font-size:11px">ğŸ’¾ Apply to Bot</button>
          </div>
        </div>
        <p style="color:var(--muted);font-size:11px;margin:4px 0 12px">ìŠ¬ë¼ì´ë”ë¡œ ê° ê³ ë˜ì˜ ì‹œê·¸ë„ ê°€ì¤‘ì¹˜ë¥¼ ì¡°ì •í•©ë‹ˆë‹¤. Apply ë²„íŠ¼ìœ¼ë¡œ ë´‡ì— ë°˜ì˜ë©ë‹ˆë‹¤.</p>
        <div id="weight-sliders"></div>
        <div id="weight-status" style="margin-top:8px;font-size:12px;color:var(--muted)"></div>
      </div>
    </div><!-- /analytics-page -->

    <!-- Algorithm Page -->
    <div id="algorithm-page" style="display:none">

      <!-- 1. Overview Flow -->
      <div class="algo-section">
        <div class="algo-title">ğŸ§  Algorithm Overview</div>
        <p style="color:var(--muted);font-size:13px;margin-bottom:16px">Kuroì˜ íŠ¸ë ˆì´ë”© ì•Œê³ ë¦¬ì¦˜ì€ ê³ ë˜ ì¶”ì  + ê¸°ìˆ ì  ë¶„ì„ì„ ê²°í•©í•œ ë‹¤ì¸µ ì‹œê·¸ë„ ì‹œìŠ¤í…œì…ë‹ˆë‹¤.</p>

        <div class="algo-flow">
          <div class="algo-node highlight">
            <div class="node-icon">ğŸ‹</div>
            <div class="node-title">Whale Tracking</div>
            <div class="node-desc">14ëª…ì˜ ê³ ë˜ í¬ì§€ì…˜ì„<br>15ì´ˆë§ˆë‹¤ ëª¨ë‹ˆí„°ë§</div>
          </div>
          <div class="algo-arrow">â†’</div>
          <div class="algo-node">
            <div class="node-icon">ğŸ“Š</div>
            <div class="node-title">Technical Analysis</div>
            <div class="node-desc">EMA, RSI, MACD, BB<br>+ MTF + Orderbook</div>
          </div>
          <div class="algo-arrow">â†’</div>
          <div class="algo-node">
            <div class="node-icon">âš–ï¸</div>
            <div class="node-title">Signal Scoring</div>
            <div class="node-desc">9ê°œ ì»´í¬ë„ŒíŠ¸<br>ê°€ì¤‘ í•©ì‚° (-100~+100)</div>
          </div>
          <div class="algo-arrow">â†’</div>
          <div class="algo-node gate">
            <div class="node-icon">ğŸš§</div>
            <div class="node-title">Safety Gates</div>
            <div class="node-desc">Threshold + Confidence<br>+ R:R + RSI Filter</div>
          </div>
          <div class="algo-arrow">â†’</div>
          <div class="algo-node highlight">
            <div class="node-icon">âš¡</div>
            <div class="node-title">Execution</div>
            <div class="node-desc">Smart Entry (Limitâ†’Market)<br>3-tier TP + Dynamic SL</div>
          </div>
        </div>
      </div>

      <!-- 2. Signal Weights -->
      <div class="algo-section">
        <div class="algo-title">âš–ï¸ Signal Component Weights</div>
        <p style="color:var(--muted);font-size:12px;margin-bottom:12px">ê° ì»´í¬ë„ŒíŠ¸ ì ìˆ˜ (-100~+100)ì— ê°€ì¤‘ì¹˜ë¥¼ ê³±í•´ í•©ì‚°í•©ë‹ˆë‹¤. ê³ ë˜ 30%ê°€ ê°€ì¥ í° ë¹„ì¤‘.</p>

        <div id="algo-weight-bars">
          <!-- Filled by JS -->
        </div>

        <div class="algo-formula">
          totalScore = Î£ (component_score Ã— weight)<br>
          = trendÃ—0.15 + momentumÃ—0.15 + volumeÃ—0.10 + onchainÃ—0.05<br>
          &nbsp;&nbsp;+ <span style="color:#22c55e;font-weight:700">whaleÃ—0.30</span> + divergenceÃ—0.10 + mtfÃ—0.10 + orderbookÃ—0.05
        </div>
      </div>

      <!-- 3. Whale Signal Pipeline -->
      <div class="algo-section">
        <div class="algo-title">ğŸ‹ Whale Signal Pipeline</div>

        <div class="algo-flow">
          <div class="algo-node">
            <div class="node-icon">ğŸ“¡</div>
            <div class="node-title">Position Scan</div>
            <div class="node-desc">14 whales Ã— Allium API<br>í¬ì§€ì…˜ + ìµœê·¼ fills</div>
          </div>
          <div class="algo-arrow">â†’</div>
          <div class="algo-node">
            <div class="node-icon">ğŸ“</div>
            <div class="node-title">Position Score</div>
            <div class="node-desc">Long % vs Short %<br>-100 ~ +100</div>
          </div>
          <div class="algo-arrow">â†’</div>
          <div class="algo-node">
            <div class="node-icon">ğŸ”„</div>
            <div class="node-title">Momentum</div>
            <div class="node-desc">ìµœê·¼ ì§„ì…/ì´íƒˆ ë°©í–¥<br>ì§€ìˆ˜ ê°ì‡  (Î»=0.18)</div>
          </div>
          <div class="algo-arrow">â†’</div>
          <div class="algo-node">
            <div class="node-icon">ğŸ§¬</div>
            <div class="node-title">Hybrid Score</div>
            <div class="node-desc">Position 60%<br>+ Momentum 40%</div>
          </div>
          <div class="algo-arrow">â†’</div>
          <div class="algo-node gate">
            <div class="node-icon">ğŸ“</div>
            <div class="node-title">Entry Distance</div>
            <div class="node-desc">í˜„ì¬ê°€ vs ê³ ë˜ ì§„ì…ê°€<br>2%ì´ë‚´ = í’€, 10%+ = ê°ì‡„</div>
          </div>
        </div>

        <div style="margin-top:16px">
          <div class="algo-formula">
            whaleScore = hybrid Ã— entryDistanceFactor<br>
            hybrid = position Ã— 0.60 + momentum Ã— 0.40<br>
            <br>
            <span style="color:var(--muted)">// Burst Detection (3+ ê³ ë˜ ë™ì‹œ ì§„ì… 30ë¶„ ë‚´)</span><br>
            if burst â†’ momentum ê°€ì¤‘ì¹˜ 0.40 â†’ ìµœëŒ€ 0.75ë¡œ ì‹œí”„íŠ¸<br>
            <span style="color:var(--muted)">// Skill Weight (í”„ë¡œí•„ ê¸°ë°˜)</span><br>
            ê° ê³ ë˜ ê¸°ì—¬ë„ = skill_weight Ã— freshness Ã— assetModifier
          </div>
        </div>
      </div>

      <!-- 4. Entry Gates -->
      <div class="algo-section">
        <div class="algo-title">ğŸš§ Entry Safety Gates</div>
        <p style="color:var(--muted);font-size:12px;margin-bottom:12px">ì‹œê·¸ë„ì´ ë°œìƒí•´ë„ ì•„ë˜ ê²Œì´íŠ¸ë¥¼ ëª¨ë‘ í†µê³¼í•´ì•¼ ì§„ì…í•©ë‹ˆë‹¤.</p>

        <table class="algo-gate-table">
          <tr><th>Gate</th><th>ì¡°ê±´</th><th>ì„¤ëª…</th></tr>
          <tr>
            <td>â‘  Score Threshold</td>
            <td><code>|score| > 35</code></td>
            <td>ê¸°ë³¸ 35ì . ë ˆì¸ì§• +10, ë³¼ë¼í‹¸ +15 ê°€ì‚°. MTF ë¶ˆì¼ì¹˜ ì‹œ +15</td>
          </tr>
          <tr>
            <td>â‘¡ Confidence Floor</td>
            <td><code>confidence > 25%</code></td>
            <td>ëª¨ë“  ì»´í¬ë„ŒíŠ¸ê°€ ê°™ì€ ë°©í–¥ì´ë©´ Ã—1.2 ë¶€ìŠ¤íŠ¸</td>
          </tr>
          <tr>
            <td>â‘¢ Risk:Reward</td>
            <td><code>R:R â‰¥ 1.5</code></td>
            <td>ATR ê¸°ë°˜ SL/TP ê±°ë¦¬ ë¹„ìœ¨. 1.5 ë¯¸ë§Œì´ë©´ ìŠ¤í‚µ</td>
          </tr>
          <tr>
            <td>â‘£ RSI Filter</td>
            <td><code>LONG: RSI < 75</code><br><code>SHORT: RSI > 25</code></td>
            <td>ê·¹ë‹¨ RSIì—ì„œ ì§„ì… ì°¨ë‹¨ (soft: threshold +5, hard: ë¸”ë¡)</td>
          </tr>
          <tr>
            <td>â‘¤ Direction Change</td>
            <td><code>trigger only</code></td>
            <td>ë°©í–¥ ì „í™˜ ì‹œì—ë§Œ ì§„ì… ì‹œë„. ê°™ì€ ë°©í–¥ ìœ ì§€ ì¤‘ì—” ëŒ€ê¸°</td>
          </tr>
          <tr>
            <td>â‘¥ Position Limits</td>
            <td><code>â‰¤ 8 concurrent</code></td>
            <td>ìµœëŒ€ 8ê°œ ë™ì‹œ í¬ì§€ì…˜. ê°™ì€ ë°©í–¥ ìµœëŒ€ 6ê°œ</td>
          </tr>
        </table>
      </div>

      <!-- 5. Execution -->
      <div class="algo-section">
        <div class="algo-title">âš¡ Execution & Risk Management</div>

        <div style="display:grid;grid-template-columns:repeat(auto-fill,minmax(280px,1fr));gap:12px">
          <div style="background:#1a1d23;border-radius:8px;padding:14px">
            <div style="font-weight:700;font-size:14px;margin-bottom:8px">ğŸ¯ Smart Entry</div>
            <div style="font-size:12px;color:var(--muted);line-height:1.6">
              1. ê³ ë˜ ì§„ì…ê°€ ê·¼ì²˜ì— <strong style="color:var(--text)">Limit Order</strong> ë°°ì¹˜<br>
              2. 30ì´ˆ íƒ€ì„ì•„ì›ƒ â†’ ë¯¸ì²´ê²° ì‹œ <strong style="color:var(--text)">Market Order</strong> ì „í™˜<br>
              3. ìŠ¬ë¦¬í”¼ì§€: Limit 0% / Market 0.1%<br>
            </div>
          </div>
          <div style="background:#1a1d23;border-radius:8px;padding:14px">
            <div style="font-weight:700;font-size:14px;margin-bottom:8px">ğŸ›¡ï¸ Stop Loss</div>
            <div style="font-size:12px;color:var(--muted);line-height:1.6">
              â€¢ ê¸°ë³¸: ATR Ã— 2.0 ê±°ë¦¬ (min 2%, max 6%)<br>
              â€¢ <strong style="color:var(--text)">Dynamic</strong>: ë³€ë™ì„± í™•ëŒ€ â†’ SL í™•ì¥<br>
              â€¢ <strong style="color:var(--text)">Momentum</strong>: ì—­ë°©í–¥ ëª¨ë©˜í…€ â†’ SL ì¶•ì†Œ<br>
              â€¢ <strong style="color:#ef4444">ê³ ë˜ ì´íƒˆ</strong>: 2+ ê³ ë˜ í´ë¡œì¦ˆ â†’ 50% ì¦‰ì‹œ ì²­ì‚°<br>
            </div>
          </div>
          <div style="background:#1a1d23;border-radius:8px;padding:14px">
            <div style="font-weight:700;font-size:14px;margin-bottom:8px">ğŸ’° Take Profit (3-tier)</div>
            <div style="font-size:12px;color:var(--muted);line-height:1.6">
              â€¢ TP1: ATR Ã— 3.0 â†’ <strong style="color:var(--green)">33% ì²­ì‚°</strong><br>
              â€¢ TP2: ATR Ã— 4.5 â†’ <strong style="color:var(--green)">33% ì²­ì‚°</strong><br>
              â€¢ TP3: Bollinger Band â†’ <strong style="color:var(--green)">34% ì²­ì‚°</strong><br>
              â€¢ ë³€ë™ì„± ìˆ˜ì¶• ì‹œ TP ìë™ ì¶•ì†Œ<br>
            </div>
          </div>
          <div style="background:#1a1d23;border-radius:8px;padding:14px">
            <div style="font-weight:700;font-size:14px;margin-bottom:8px">ğŸ“ Position Sizing</div>
            <div style="font-size:12px;color:var(--muted);line-height:1.6">
              â€¢ ê¸°ë³¸: ì”ì•¡ì˜ <strong style="color:var(--text)">2%</strong> ë¦¬ìŠ¤í¬/íŠ¸ë ˆì´ë“œ<br>
              â€¢ Kelly Criterion: ì¶©ë¶„í•œ ê±°ë˜ í›„ ìë™ ì¡°ì •<br>
              â€¢ ë ˆë²„ë¦¬ì§€: BTC/ETH/SOL <strong style="color:var(--text)">5x</strong>, ë‚˜ë¨¸ì§€ <strong style="color:var(--text)">2x</strong><br>
              â€¢ Max drawdown: 15% â†’ ê±°ë˜ ì¤‘ë‹¨<br>
            </div>
          </div>
        </div>
      </div>

      <!-- 6. Current Config -->
      <div class="algo-section">
        <div class="algo-title">âš™ï¸ Live Configuration</div>
        <div id="algo-live-config" style="font-size:12px;color:var(--muted)">Loading...</div>
      </div>

    </div><!-- /algorithm-page -->

    <!-- Footer -->
    <div class="footer">
      Auto-refresh: 30s â€¢ Built by Kuro ğŸ¤–
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/chart.js@4/dist/chart.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
  <script>
    // Portfolio Chart
    let portfolioChart = null;
    let currentRange = '7d';

    function switchRange(range) {
      currentRange = range;
      document.querySelectorAll('.chart-tab').forEach(t => t.classList.remove('active'));
      document.querySelector(`.chart-tab[data-range="${range}"]`).classList.add('active');
      fetchPortfolio(range);
    }

    async function fetchPortfolio(range) {
      try {
        const data = await apiPortfolio(range || currentRange);
        renderChart(data);
        renderChartSummary(data);
      } catch (e) { console.error('Portfolio fetch error:', e); }
    }

    function renderChart(data) {
      const canvas = document.getElementById('portfolio-chart');
      const ctx = canvas.getContext('2d');
      const isPositive = data.pnlAmount >= 0;
      const lineColor = isPositive ? '#22c55e' : '#ef4444';

      if (portfolioChart) portfolioChart.destroy();

      // Gradient fill
      const gradient = ctx.createLinearGradient(0, 0, 0, canvas.parentElement.clientHeight);
      gradient.addColorStop(0, isPositive ? 'rgba(34,197,94,0.15)' : 'rgba(239,68,68,0.15)');
      gradient.addColorStop(1, 'rgba(0,0,0,0)');

      portfolioChart = new Chart(ctx, {
        type: 'line',
        data: {
          labels: data.points.map(p => p.time),
          datasets: [{
            data: data.points.map(p => p.value),
            borderColor: lineColor,
            backgroundColor: gradient,
            fill: true,
            tension: 0.3,
            pointRadius: 0,
            pointHitRadius: 10,
            borderWidth: 2,
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: { display: false },
            tooltip: {
              backgroundColor: '#1a1a1e',
              borderColor: '#333',
              borderWidth: 1,
              titleFont: { family: "'JetBrains Mono', monospace", size: 11 },
              bodyFont: { family: "'JetBrains Mono', monospace", size: 12 },
              padding: 10,
              displayColors: false,
              callbacks: {
                title: function(ctx) {
                  return new Date(ctx[0].parsed.x).toLocaleString('ko-KR', { month:'short', day:'numeric', hour:'2-digit', minute:'2-digit' });
                },
                label: function(ctx) {
                  const v = ctx.parsed.y;
                  return (v >= 0 ? '+$' : '-$') + Math.abs(v).toFixed(2);
                }
              }
            }
          },
          scales: {
            x: {
              type: 'time',
              time: {
                tooltipFormat: 'PPp',
                displayFormats: {
                  hour: 'HH:mm',
                  day: 'M/d',
                  week: 'M/d',
                }
              },
              grid: { display: false },
              ticks: {
                color: '#71717a',
                font: { family: "'JetBrains Mono', monospace", size: 10 },
                maxTicksLimit: 6,
              },
              border: { display: false },
            },
            y: {
              grid: {
                color: 'rgba(255,255,255,0.04)',
                drawBorder: false,
              },
              ticks: {
                color: '#71717a',
                font: { family: "'JetBrains Mono', monospace", size: 10 },
                callback: (v) => (v >= 0 ? '+$' : '-$') + Math.abs(v).toFixed(0),
                maxTicksLimit: 5,
              },
              border: { display: false },
            }
          },
          interaction: { intersect: false, mode: 'index' },
          animation: { duration: 400 },
        }
      });
    }

    function renderChartSummary(data) {
      const valueEl = document.getElementById('chart-value');
      const pnlEl = document.getElementById('chart-pnl');
      const totalPnl = data.currentPnl || 0;
      const sign = totalPnl >= 0 ? '+' : '-';
      const cls = totalPnl >= 0 ? 'green' : 'red';
      valueEl.className = 'chart-value ' + cls;
      valueEl.textContent = `${sign}$${Math.abs(totalPnl).toFixed(2)}`;
      const pct = data.pnlPercent || 0;
      const pctSign = pct >= 0 ? '+' : '';
      pnlEl.className = 'chart-pnl ' + cls;
      pnlEl.textContent = `(${pctSign}${pct.toFixed(2)}%)`;

      // Realized / Unrealized breakdown
      const realizedEl = document.getElementById('chart-realized');
      const unrealizedEl = document.getElementById('chart-unrealized');
      const rPnl = data.realizedPnl || 0;
      const uPnl = data.unrealizedPnl || 0;
      const rSign = rPnl >= 0 ? '+' : '-';
      const rCls = rPnl >= 0 ? 'green' : 'red';
      realizedEl.className = rCls;
      realizedEl.textContent = `${rSign}$${Math.abs(rPnl).toFixed(2)}`;
      const uSign = uPnl >= 0 ? '+' : '-';
      const uCls = uPnl >= 0 ? 'green' : 'red';
      unrealizedEl.className = uCls;
      unrealizedEl.textContent = `${uSign}$${Math.abs(uPnl).toFixed(2)}`;

      // Stats bar is updated by fetchData() with API data, not chart data
    }

    // State
    let whaleExpanded = false;
    let tradesExpanded = false;
    let signalsExpanded = false;
    let fullWhaleData = [];
    let fullTradesData = [];
    let fullSignalsData = [];
    
    function toggleWhaleTable() {
      whaleExpanded = !whaleExpanded;
      document.getElementById('toggle-whale').textContent = whaleExpanded ? 'Show Less' : 'Show All';
      renderWhaleTable(fullWhaleData);
    }
    
    function toggleTrades() {
      tradesExpanded = !tradesExpanded;
      renderTrades(fullTradesData);
    }
    
    function toggleSignals() {
      signalsExpanded = !signalsExpanded;
      renderSignals(fullSignalsData);
    }
    
    // Formatters
    const fmt = {
      money: (v) => {
        if (v == null || isNaN(v)) return '$0.00';
        if (Math.abs(v) >= 1e6) return '$' + (v/1e6).toFixed(2) + 'M';
        if (Math.abs(v) >= 1e3) return '$' + (v/1e3).toFixed(1) + 'K';
        return '$' + v.toFixed(2);
      },
      price: (v) => '$' + v.toLocaleString('en-US', {maximumFractionDigits: 2}),
      pnl: (v) => {
        const sign = v >= 0 ? '+' : '';
        const cls = v >= 0 ? 'green' : 'red';
        return `<span class="${cls}">${sign}${fmt.money(v)}</span>`;
      },
      time: (ts) => new Date(ts).toLocaleTimeString('ko-KR', {hour:'2-digit', minute:'2-digit'}),
      badge: (dir) => {
        const cls = dir === 'LONG' ? 'badge-long' : (dir === 'SHORT' ? 'badge-short' : 'badge-neutral');
        return `<span class="badge ${cls}">${dir}</span>`;
      },
      ratio: (pct) => {
        return `<div class="ratio-bar"><div class="ratio-fill" style="width:${pct}%"></div></div><span class="ratio-text">${pct.toFixed(0)}%L</span>`;
      }
    };

    // Render Whale Table
    function renderWhaleTable(data) {
      fullWhaleData = data; // ì „ì²´ ë°ì´í„° ì €ì¥
      const tbody = document.getElementById('whale-tbody');
      const toggleBtn = document.getElementById('toggle-whale');
      
      if (!data.length) {
        tbody.innerHTML = '<tr><td colspan="11" style="text-align:center;color:var(--muted);padding:24px;">No whale positions</td></tr>';
        toggleBtn.style.display = 'none';
        return;
      }
      
      // 5ê°œë§Œ ë³´ì´ê±°ë‚˜ ì „ì²´
      const displayData = whaleExpanded ? data : data.slice(0, 5);
      toggleBtn.style.display = data.length > 5 ? 'inline-block' : 'none';
      toggleBtn.textContent = whaleExpanded ? 'Show Less' : `Show All (${data.length})`;
      
      tbody.innerHTML = displayData.map(a => {
        const mom = a.momentum || 0;
        const momClass = mom > 20 ? 'green' : (mom < -20 ? 'red' : 'muted');
        const momArrow = mom > 20 ? 'â†‘' : (mom < -20 ? 'â†“' : 'â†’');
        const alignBadge = a.agreement === 'ALIGNED' 
          ? '<span class="badge badge-long" style="font-size:9px;margin-left:4px;">âœ“</span>' 
          : '<span class="badge badge-short" style="font-size:9px;margin-left:4px;">âš </span>';
        return `
        <tr>
          <td><strong>${a.coin}</strong></td>
          <td>${fmt.badge(a.netDirection)}</td>
          <td class="center"><span class="${momClass}">${momArrow} ${mom > 0 ? '+' : ''}${mom}</span>${alignBadge}</td>
          <td class="right">${fmt.money(a.netValue)}</td>
          <td class="center"><span class="green">${a.longCount}L</span> / <span class="red">${a.shortCount}S</span></td>
          <td class="right">${a.avgLongEntry > 0 ? fmt.price(a.avgLongEntry) : '-'}</td>
          <td class="right">${a.avgShortEntry > 0 ? fmt.price(a.avgShortEntry) : '-'}</td>
          <td class="right">${fmt.pnl(a.longPnL)}</td>
          <td class="right">${fmt.pnl(a.shortPnL)}</td>
          <td class="center">${fmt.ratio(a.longRatio)}</td>
        </tr>
      `}).join('');
    }

    // Render Trades
    function renderTrades(trades) {
      fullTradesData = trades; // ì „ì²´ ë°ì´í„° ì €ì¥
      const tbody = document.getElementById('trades-tbody');
      const toggleBtn = document.getElementById('toggle-trades');
      
      if (!trades.length) {
        tbody.innerHTML = '<tr><td colspan="7" style="text-align:center;color:var(--muted);padding:24px;">No recent trades</td></tr>';
        toggleBtn.style.display = 'none';
        return;
      }
      
      // 7ê°œë§Œ ë³´ì´ê±°ë‚˜ ì „ì²´ (ìµœëŒ€ 30ê°œ)
      const displayData = tradesExpanded ? trades.slice(0, 30) : trades.slice(0, 7);
      toggleBtn.style.display = trades.length > 7 ? 'inline-block' : 'none';
      toggleBtn.textContent = tradesExpanded ? 'Show Less' : `Show All (${Math.min(trades.length, 30)})`;
      
      tbody.innerHTML = displayData.map(t => {
        const action = t.direction || (t.side === 'B' ? 'BUY' : 'SELL');
        const isLong = action.includes('Long') || t.side === 'B';
        return `
          <tr>
            <td class="muted">${fmt.time(t.time)}</td>
            <td>${t.whale}</td>
            <td><strong>${t.coin}</strong></td>
            <td>${fmt.badge(isLong ? 'LONG' : 'SHORT')}</td>
            <td class="right">${t.size.toFixed(4)}</td>
            <td class="right">${fmt.price(t.price)}</td>
            <td class="right">${fmt.money(t.value)}</td>
          </tr>
        `;
      }).join('');
    }

    // Render Signals
    function renderSignals(signals) {
      fullSignalsData = signals; // ì „ì²´ ë°ì´í„° ì €ì¥
      const tbody = document.getElementById('signals-tbody');
      const toggleBtn = document.getElementById('toggle-signals');
      
      if (!signals.length) {
        tbody.innerHTML = '<tr><td colspan="6" style="text-align:center;color:var(--muted);padding:24px;">No consensus signals (need 5+ whales same direction)</td></tr>';
        toggleBtn.style.display = 'none';
        return;
      }
      
      // 7ê°œë§Œ ë³´ì´ê±°ë‚˜ ì „ì²´
      const displayData = signalsExpanded ? signals : signals.slice(0, 7);
      toggleBtn.style.display = signals.length > 7 ? 'inline-block' : 'none';
      toggleBtn.textContent = signalsExpanded ? 'Show Less' : `Show All (${signals.length})`;
      
      tbody.innerHTML = displayData.map(s => `
        <tr>
          <td><strong>${s.coin}</strong></td>
          <td>${fmt.badge(s.direction)}</td>
          <td class="center">${s.whaleCount} / ${s.totalWhales}</td>
          <td class="right">${fmt.price(s.avgEntry)}</td>
          <td class="right">${fmt.money(s.totalValue)}</td>
          <td class="center">${fmt.ratio(s.longRatio)}</td>
        </tr>
      `).join('');
    }

    // Update margin info in stats bar
    function updateMarginStats(margin) {
      if (!margin) return;
      const pct = margin.usedPct || 0;
      const pctClass = pct > 80 ? 'red' : pct > 50 ? '' : 'green';
      document.getElementById('margin-info').innerHTML = `<span class="${pctClass}">${fmt.money(margin.totalMarginUsed)} (${pct.toFixed(1)}%)</span>`;
      document.getElementById('withdrawable').textContent = fmt.money(margin.withdrawable || 0);
      document.getElementById('pos-value').textContent = fmt.money(margin.positionValue);
      document.getElementById('acct-leverage').textContent = margin.leverage.toFixed(2) + 'x';
    }

    // Render My Positions (compact table with margin)
    function renderPositions(positions) {
      const container = document.getElementById('my-positions');
      if (!positions.length) {
        container.innerHTML = '<div class="my-position empty">No positions</div>';
        return;
      }
      container.innerHTML = `<div class="table-wrap"><table>
        <thead><tr><th>Coin</th><th>Side</th><th class="right">Size</th><th class="right">Entry</th><th class="right">Price</th><th class="right">PnL</th><th class="right">Lev</th><th class="right">Margin</th></tr></thead>
        <tbody>${positions.map(p => `<tr>
          <td><strong>${p.coin}</strong></td>
          <td>${fmt.badge(p.direction)}</td>
          <td class="right">${p.size.toFixed(4)}</td>
          <td class="right">${fmt.price(p.entryPrice)}</td>
          <td class="right">${fmt.price(p.currentPrice)}</td>
          <td class="right">${fmt.pnl(p.pnl)}</td>
          <td class="right">${p.leverage}x</td>
          <td class="right">${fmt.money(p.marginUsed || 0)}</td>
        </tr>`).join('')}</tbody></table></div>`;
    }

    // Helpers
    function relativeTime(ts) {
      const diff = Date.now() - new Date(ts).getTime();
      const mins = Math.floor(diff / 60000);
      if (mins < 1) return 'ë°©ê¸ˆ';
      if (mins < 60) return `${mins}ë¶„ ì „`;
      const hrs = Math.floor(mins / 60);
      if (hrs < 24) return `${hrs}ì‹œê°„ ì „`;
      const days = Math.floor(hrs / 24);
      return `${days}ì¼ ì „`;
    }

    function typeEmoji(type) {
      return { ENTRY: 'ğŸŸ¢', EXIT: 'ğŸ”´', FLIP: 'ğŸ”„', PERIODIC: 'â¸', SYSTEM: 'âš™ï¸', TRADE: 'ğŸ“Š' }[type] || 'â€¢';
    }

    function escapeHtml(str) {
      return String(str).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
    }

    // Render Decision + Timeline
    function renderDecision(data) {
      const box = document.getElementById('decision-box');
      const c = data.current;
      const reasons = escapeHtml(c.reason).replace(/\n\n/g, '<br><br>').replace(/\n/g, '<br>');
      box.innerHTML = `
        <div class="decision-action">${c.emoji} ${escapeHtml(c.action)}</div>
        <div class="decision-reason">${reasons}</div>
        <div class="decision-scores">
          <span class="score-item"><span class="score-label">BTC Whale:</span> <strong>${escapeHtml(c.btcWhale || '--')}</strong> <span class="muted">(${c.btcScore || '--'}%)</span></span>
          <span class="score-item"><span class="score-label">ETH Whale:</span> <strong>${escapeHtml(c.ethWhale || '--')}</strong> <span class="muted">(${c.ethScore || '--'}%)</span></span>
        </div>
      `;

      // Stats
      if (data.stats) {
        const s = data.stats;
        const pnlClass = s.totalPnL >= 0 ? 'green' : 'red';
        const pnlStr = s.totalPnL >= 0 ? `+$${s.totalPnL.toFixed(2)}` : `-$${Math.abs(s.totalPnL).toFixed(2)}`;
        box.innerHTML += `
          <div class="decision-scores">
            <span class="score-item"><span class="score-label">Trades:</span> <strong>${s.totalTrades}</strong></span>
            <span class="score-item"><span class="score-label">Win:</span> <strong>${escapeHtml(s.winRate || 'N/A')}</strong></span>
            <span class="score-item"><span class="score-label">PnL:</span> <strong class="${pnlClass}">${pnlStr}</strong></span>
          </div>
        `;
      }

      // Timeline
      const historyEl = document.getElementById('decision-history');
      const history = data.history || [];
      if (!history.length) {
        historyEl.innerHTML = '';
        return;
      }

      fullHistoryData = history;
      historyExpanded = false;
      renderTimeline();
    }

    let fullHistoryData = [];
    let historyExpanded = false;

    function buildDetailHtml(h) {
      const d = h.detail;
      if (!d) return '';
      let rows = [];

      // Signal reasoning (from Vercel Blob â€” if available)
      const sig = d.signal;
      if (sig) {
        // Score + confidence
        const confPct = ((sig.confidence || 0) * 100).toFixed(0);
        rows.push(`<div class="tl-detail-row"><span class="tl-detail-label">ì‹œê·¸ë„</span><span>ìŠ¤ì½”ì–´ <strong>${sig.score?.toFixed(0) || '?'}</strong> (ì‹ ë¢°ë„ ${confPct}%)</span></div>`);

        // Component scores
        if (sig.scores) {
          const s = sig.scores;
          const scoreParts = [];
          if (s.trend != null) scoreParts.push(`Trend: ${s.trend.toFixed(0)}`);
          if (s.momentum != null) scoreParts.push(`Momentum: ${s.momentum.toFixed(0)}`);
          if (s.volume != null) scoreParts.push(`Volume: ${s.volume.toFixed(0)}`);
          if (s.whale != null) scoreParts.push(`Whale: ${s.whale.toFixed(0)}`);
          if (scoreParts.length) rows.push(`<div class="tl-detail-row"><span class="tl-detail-label">ìŠ¤ì½”ì–´</span><span style="font-size:11px;opacity:0.8">${scoreParts.join(' | ')}</span></div>`);
        }

        // Technicals
        if (sig.technicals) {
          const t = sig.technicals;
          const techParts = [];
          if (t.rsi != null) techParts.push(`RSI: ${t.rsi.toFixed(1)}`);
          if (t.macd != null) techParts.push(`MACD: ${t.macd.toFixed(2)}`);
          if (t.trend) techParts.push(`Trend: ${t.trend}`);
          if (techParts.length) rows.push(`<div class="tl-detail-row"><span class="tl-detail-label">ê¸°ìˆ ì§€í‘œ</span><span style="font-size:11px;opacity:0.8">${techParts.join(' | ')}</span></div>`);
        }

        // Whale consensus
        if (sig.whale) {
          const w = sig.whale;
          const wDir = w.direction || '?';
          const wCount = w.whaleCount || 0;
          const wTotal = w.totalWhales || WATCHED_WHALES.length;
          rows.push(`<div class="tl-detail-row"><span class="tl-detail-label">ê³ ë˜ í•©ì˜</span><span>${wDir} (${wCount}/${wTotal}ëª…)</span></div>`);
        }

        // Reasons
        if (sig.reasons && sig.reasons.length > 0) {
          rows.push('<div class="tl-detail-sep"></div>');
          rows.push(`<div class="tl-detail-label" style="margin-bottom:4px;">ì§„ì… ì´ìœ </div>`);
          sig.reasons.forEach(r => {
            rows.push(`<div class="tl-detail-row" style="padding-left:8px"><span style="opacity:0.9">â€¢ ${escapeHtml(r)}</span></div>`);
          });
        }

        // Fill info (compact)
        rows.push('<div class="tl-detail-sep"></div>');
        rows.push(`<div class="tl-detail-row"><span class="tl-detail-label">ì²´ê²°</span><span>${d.size.toPrecision(4)} @ $${(d.avgPrice || 0).toLocaleString('en-US', {maximumFractionDigits:2})} (${sig.leverage || '?'}x)</span></div>`);
      } else if (d.size != null) {
        // No signal data â€” fallback to fill info only
        rows.push(`<div class="tl-detail-row"><span class="tl-detail-label">ì²´ê²°</span><span>${d.size.toPrecision(4)} @ $${(d.avgPrice || 0).toLocaleString('en-US', {maximumFractionDigits:2})}</span></div>`);
        if (d.fee) rows.push(`<div class="tl-detail-row"><span class="tl-detail-label">ìˆ˜ìˆ˜ë£Œ</span><span>$${d.fee.toFixed(4)}</span></div>`);
        if (d.fillCount > 1) rows.push(`<div class="tl-detail-row"><span class="tl-detail-label">ì²´ê²° ìˆ˜</span><span>${d.fillCount}ê±´</span></div>`);
        if (d.whales && (d.whales.long || d.whales.short)) {
          rows.push(`<div class="tl-detail-row"><span class="tl-detail-label">ê³ ë˜</span><span><span class="green">${d.whales.long}L</span> / <span class="red">${d.whales.short}S</span></span></div>`);
        }
      }

      // PERIODIC â€” current state detail
      if (d.positions && d.positions.length > 0) {
        rows.push('<div class="tl-detail-sep"></div>');
        d.positions.forEach(p => {
          const pSign = p.pnl >= 0 ? '+' : '';
          const pClass = p.pnl >= 0 ? 'green' : 'red';
          rows.push(`<div class="tl-detail-row"><span>${p.direction} ${escapeHtml(p.coin)} ${p.leverage}x</span><span class="${pClass}">${pSign}$${p.pnl.toFixed(2)}</span></div>`);
        });
      }
      if (d.topWhales && d.topWhales.length > 0) {
        rows.push('<div class="tl-detail-sep"></div>');
        rows.push(`<div class="tl-detail-label" style="margin-bottom:2px;">ê³ ë˜ ë™í–¥</div>`);
        d.topWhales.forEach(w => {
          rows.push(`<div class="tl-detail-row"><span>${escapeHtml(w.coin)}</span><span><span class="green">${w.long}L</span> / <span class="red">${w.short}S</span></span></div>`);
        });
      }
      if (d.accountValue) {
        rows.push(`<div class="tl-detail-row"><span class="tl-detail-label">ê³„ì¢Œê°€ì¹˜</span><span>$${d.accountValue.toFixed(2)}</span></div>`);
      }

      return `<div class="tl-detail">${rows.join('')}</div>`;
    }

    function toggleDetail(btn) {
      const detail = btn.closest('.tl-body').querySelector('.tl-detail');
      if (detail) {
        detail.classList.toggle('open');
        btn.textContent = detail.classList.contains('open') ? 'â–¼ ì ‘ê¸°' : 'â–¶ ìƒì„¸';
      }
    }

    function renderTimeline() {
      const historyEl = document.getElementById('decision-history');
      const display = historyExpanded ? fullHistoryData : fullHistoryData.slice(0, 4);
      const hasMore = fullHistoryData.length > 4;

      historyEl.innerHTML = `
        ${display.map(h => {
          const pnlHtml = h.pnl && h.pnl !== 0
            ? `<span class="tl-pnl ${h.pnl >= 0 ? 'green' : 'red'}">${h.pnl >= 0 ? '+' : ''}$${h.pnl.toFixed(2)}</span>`
            : '';
          const detailHtml = h.detail ? buildDetailHtml(h) : '';
          const toggleHtml = h.detail ? `<button class="tl-toggle" onclick="toggleDetail(this)">â–¶ ìƒì„¸</button>` : '';
          return `<div class="tl-entry">
            <div class="tl-dot ${h.type}"></div>
            <div class="tl-body">
              <div class="tl-head">
                <span class="tl-action">${typeEmoji(h.type)} ${escapeHtml(h.action)}${pnlHtml}</span>
                <span class="tl-time">${toggleHtml} ${relativeTime(h.timestamp)}</span>
              </div>
              <div class="tl-reason">${escapeHtml(h.reason)}</div>
              ${detailHtml}
            </div>
          </div>`;
        }).join('')}
        ${hasMore ? `<button class="refresh-btn" style="width:100%;margin-top:8px;" onclick="toggleHistory()">${historyExpanded ? 'ì ‘ê¸°' : 'ë”ë³´ê¸° (' + fullHistoryData.length + ')'}</button>` : ''}
      `;
    }

    function toggleHistory() {
      historyExpanded = !historyExpanded;
      renderTimeline();
    }

    // Fetch Data
    async function fetchData() {
      try {
        const data = await apiData();
        
        // Stats
        document.getElementById('account-value').textContent = fmt.money(data.account?.value || 0);
        document.getElementById('btc-price').textContent = fmt.price(data.prices?.BTC || 0);
        document.getElementById('eth-price').textContent = fmt.price(data.prices?.ETH || 0);
        document.getElementById('update-time').textContent = fmt.time(data.updatedAt || Date.now());

        // PnL
        const realizedPnl = data.account?.realizedPnl || 0;
        const unrealizedPnl = data.account?.unrealizedPnl || 0;
        
        // Update Realized PnL
        const realizedEl = document.getElementById('realized-pnl');
        const rSign = realizedPnl >= 0 ? '+' : '';
        realizedEl.textContent = rSign + fmt.money(realizedPnl);
        realizedEl.className = 'stat-value ' + (realizedPnl >= 0 ? 'green' : 'red');
        
        // Update Unrealized PnL
        const pnlEl = document.getElementById('total-pnl');
        const pnlSign = unrealizedPnl >= 0 ? '+' : '';
        pnlEl.textContent = pnlSign + fmt.money(unrealizedPnl);
        pnlEl.className = 'stat-value ' + (unrealizedPnl >= 0 ? 'green' : 'red');

        // Tables
        renderWhaleTable(data.aggregate || []);
        renderTrades(data.recentTrades || []);
        renderSignals(data.copySignals || []);
        renderPositions(data.account?.positions || []);
        updateMarginStats(data.account?.margin || null);
      } catch(e) {
        console.error('Data fetch error:', e);
        document.getElementById('update-time').textContent = 'âš ï¸ API error - retrying...';
      }
    }

    async function fetchDecision() {
      try {
        const data = await apiDecisions();
        renderDecision(data);
      } catch(e) { console.error('Decision fetch error:', e); }
    }

    function refresh() {
      fetchData();
      fetchDecision();
      fetchPortfolio(currentRange);
      setTimeout(fetchWhaleFills, 3000); // delay whale fills to avoid burst
    }

    // ============================================================
    // INLINE API CONSTANTS (must be defined before init calls)
    // ============================================================
    const HL_API = 'https://api.hyperliquid.xyz';
    const ALLIUM_API = 'https://api.allium.so/api/v1/developer/trading/hyperliquid';
    const ALLIUM_KEY = 'TBivNLFBD5OjafDRbd7QxhBcGEb2xt';
    const WALLET = '0xff48c5bEe24DD4905ef23DDdFe10F02FEf51F1dc';
    // Bot config (auto-synced from kuro-trading, fallback to defaults)
    window._botConfig = { entryThreshold: 35, weights: { trend: 0.15, momentum: 0.15, volume: 0.10, onchain: 0.05, whale: 0.30, divergence: 0.10, mtf: 0.10, orderbook: 0.05 }, leverageTiers: { BTC: 5, ETH: 5, SOL: 5, default: 2 }, maxPairs: 8 };
    const config_entryThreshold = () => window._botConfig?.entryThreshold || 35;
    const WATCHED_WHALES = [
      '0x3fc56e944aa7b1594c85861b2d46a07f82a2c0c1',
      '0x3ff54fd26855db3758d0b5ae7aed47440c47f705',
      '0x7a6d5fc57f6906f337c48fe2763c3a501304f79c',
      '0xbfc79c444c41a74516bf31237ebf586a231480b4',
      '0xac7476e14f768e3e67c195e79c2490dd20c70127',
      '0x091144e651b334341eabdbbbfed644ad0100023e',
      '0x5559da6ec434c5723d0ce9c4da7f29e3f8a3d43b',
      '0xaf0fdd39e5d92499b0ed9f68693da99c0ec1e92e',
      '0xa312114b5795dff9b8db50474dd57701aa78ad1e',
      '0x5647249079e257329ecb6f46ed41821d3c69e7de',
      '0x63d417a577b50c96f4f09148d4e4d70950db0522',
      '0x67fcc46ed2a63971697dad2fc7bb0091fe89e51d',
      '0xe02e420ec55b4e03924d77c7b342c012541ba2d3',
      '0x8bcf7a888c66f635ac4a2caf42a8dd12a3b20b14',
    ];

    // HL direct â€” only for lightweight calls (allMids, own account)
    function hlFetch(body) {
      return fetch(`${HL_API}/info`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(body),
      }).then(r => r.json());
    }

    // Allium proxy â€” for heavy calls (whale positions, fills) â€” no rate limit
    function alliumFetch(path, body) {
      return fetch(`${ALLIUM_API}${path}`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json', 'X-API-KEY': ALLIUM_KEY },
        body: JSON.stringify(body),
      }).then(r => r.json());
    }
    function alliumInfo(body) { return alliumFetch('/info', body); }
    function alliumFills(body) { return alliumFetch('/info/fills', body); }

    // ---- apiData ----
    async function apiData() {
      // Fetch core data (separate fills to avoid blocking if it fails)
      const [rawPerpState, rawSpotState, rawPrices] = await Promise.all([
        hlFetch({ type: 'clearinghouseState', user: WALLET }).catch(() => null),
        hlFetch({ type: 'spotClearinghouseState', user: WALLET }).catch(() => ({ balances: [] })),
        hlFetch({ type: 'allMids' }).catch(() => ({})),
      ]);
      const perpState = rawPerpState || { marginSummary: { accountValue: '0' }, assetPositions: [] };
      const spotState = rawSpotState || { balances: [] };
      const prices = rawPrices || {};

      // Fetch fills separately with fallback (may fail for new wallets)
      let myFills = [];
      try {
        const fillsResult = await hlFetch({ type: 'userFills', user: WALLET });
        myFills = Array.isArray(fillsResult) ? fillsResult : [];
      } catch(e) { myFills = []; }

      const usdcBalance = spotState?.balances?.find(b => b.coin === 'USDC');
      const totalBalance = usdcBalance ? parseFloat(usdcBalance.total) : 0;
      const account = { ...perpState, totalBalance, spotBalances: spotState?.balances || [] };

      const whaleCache = await fetchWhaleData(); // shared cache
      const whaleAccounts = whaleCache.accounts;
      const whalePositions = whaleAccounts.map((wa, i) => ({
        address: WATCHED_WHALES[i],
        positions: (wa.assetPositions || []).filter(p => parseFloat(p.position.szi) !== 0).map(p => ({
          coin: p.position.coin,
          direction: parseFloat(p.position.szi) > 0 ? 'LONG' : 'SHORT',
          size: Math.abs(parseFloat(p.position.szi)),
          entryPrice: parseFloat(p.position.entryPx),
          currentPrice: parseFloat(prices[p.position.coin] || 0),
          value: Math.abs(parseFloat(p.position.szi)) * parseFloat(prices[p.position.coin] || 0),
          pnl: parseFloat(p.position.unrealizedPnl || 0),
          leverage: parseFloat(p.position.leverage?.value || 1),
        })),
        totalValue: (wa.assetPositions || []).reduce((sum, p) => {
          return sum + Math.abs(parseFloat(p.position.szi)) * parseFloat(prices[p.position.coin] || 0);
        }, 0),
      }));

      // Aggregate by coin
      const coinMap = {};
      for (const wp of whalePositions) {
        for (const pos of wp.positions) {
          if (!coinMap[pos.coin]) {
            coinMap[pos.coin] = { coin: pos.coin, longCount: 0, shortCount: 0, totalCount: 0,
              longValue: 0, shortValue: 0, netValue: 0, avgLongEntry: 0, avgShortEntry: 0,
              longPnL: 0, shortPnL: 0, longRatio: 0, momentum: 0, netDirection: 'NEUTRAL', agreement: 'MIXED' };
          }
          const c = coinMap[pos.coin];
          c.totalCount++;
          if (pos.direction === 'LONG') {
            c.longCount++; c.longValue += pos.value; c.avgLongEntry += pos.entryPrice;
            c.longPnL += pos.pnl;
          } else {
            c.shortCount++; c.shortValue += pos.value; c.avgShortEntry += pos.entryPrice;
            c.shortPnL += pos.pnl;
          }
        }
      }
      for (const c of Object.values(coinMap)) {
        if (c.longCount > 0) c.avgLongEntry = c.avgLongEntry / c.longCount;
        if (c.shortCount > 0) c.avgShortEntry = c.avgShortEntry / c.shortCount;
        c.netValue = c.longValue - c.shortValue;
        c.longRatio = c.totalCount > 0 ? Math.round((c.longCount / c.totalCount) * 100) : 0;
        c.netDirection = c.longCount > c.shortCount ? 'LONG' : (c.shortCount > c.longCount ? 'SHORT' : 'NEUTRAL');
        c.agreement = Math.abs(c.longCount - c.shortCount) >= 2 ? 'ALIGNED' : 'MIXED';
        c.momentum = c.longCount > 0 || c.shortCount > 0
          ? Math.round(((c.longCount - c.shortCount) / c.totalCount) * 100)
          : 0;
      }
      const aggregate = Object.values(coinMap).sort((a, b) => b.netValue - a.netValue);

      // Use cached whale fills (fetched separately every 2min to avoid rate limits)
      const recentTrades = _whaleFillsCache.trades;

      const copySignals = aggregate.filter(a => a.totalCount >= 5).map(a => {
        const direction = a.longCount > a.shortCount ? 'LONG' : a.shortCount > a.longCount ? 'SHORT' : 'NEUTRAL';
        const whaleCount = direction === 'LONG' ? a.longCount : a.shortCount;
        return { coin: a.coin, direction, whaleCount, totalWhales: a.totalCount,
          avgEntry: direction === 'LONG' ? a.avgLongEntry : a.avgShortEntry,
          totalValue: direction === 'LONG' ? a.longValue : a.shortValue, longRatio: a.longRatio };
      }).filter(s => s.direction !== 'NEUTRAL' && s.whaleCount >= 5);

      const realizedPnl = (Array.isArray(myFills) ? myFills : []).filter(f => parseFloat(f.closedPnl || 0) !== 0)
        .reduce((sum, f) => sum + parseFloat(f.closedPnl), 0);

      const myPositions = (account.assetPositions || []).filter(p => parseFloat(p.position.szi) !== 0).map(p => {
        const coin = p.position.coin;
        const currentPrice = parseFloat(prices[coin] || 0);
        const size = Math.abs(parseFloat(p.position.szi));
        const leverage = parseFloat(p.position.leverage?.value || 1);
        const marginUsed = currentPrice > 0 && leverage > 0 ? (size * currentPrice) / leverage : 0;
        return { coin, direction: parseFloat(p.position.szi) > 0 ? 'LONG' : 'SHORT', size,
          entryPrice: parseFloat(p.position.entryPx), currentPrice,
          pnl: parseFloat(p.position.unrealizedPnl || 0), leverage, marginUsed };
      });

      const accountValue = parseFloat(account.marginSummary?.accountValue || 0);
      const totalMarginUsed = parseFloat(account.marginSummary?.totalMarginUsed || 0);
      const withdrawable = parseFloat(account.withdrawable || 0);
      const marginUsedPercent = accountValue > 0 ? (totalMarginUsed / accountValue * 100) : 0;
      const totalPositionValue = parseFloat(account.marginSummary?.totalNtlPos || 0);
      const effectiveLeverage = accountValue > 0 ? (totalPositionValue / accountValue) : 0;
      const unrealizedPnl = myPositions.reduce((sum, p) => sum + p.pnl, 0);

      return {
        account: {
          value: parseFloat(account.totalBalance || accountValue),
          accountValue, marginUsed: totalMarginUsed,
          marginUsedPercent: marginUsedPercent.toFixed(1), withdrawable,
          totalBalance: parseFloat(account.totalBalance || 0),
          realizedPnl, unrealizedPnl, positions: myPositions,
          margin: { totalMarginUsed, usedPct: parseFloat(marginUsedPercent.toFixed(1)),
            withdrawable, positionValue: totalPositionValue, leverage: effectiveLeverage },
        },
        whales: whalePositions, aggregate, recentTrades: recentTrades.slice(0, 30),
        copySignals, prices: { BTC: parseFloat(prices.BTC || 0), ETH: parseFloat(prices.ETH || 0) },
        updatedAt: new Date().toISOString(),
      };
    }

    // ---- apiPortfolio ----
    const RANGE_TO_PERIOD = { '7d': 'perpWeek', '30d': 'perpMonth', 'all': 'perpAllTime' };
    const INTERVAL_30M = 30 * 60 * 1000;

    function hlPost(type, extra = {}) {
      return fetch(`${HL_API}/info`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ type, ...extra }),
      }).then(r => r.json());
    }

    async function build1dPnl(account) {
      const now = Date.now();
      const start = now - 24 * 60 * 60 * 1000;
      const fills = await hlPost('userFillsByTime', { user: WALLET, startTime: start, endTime: now });
      const sortedFills = (Array.isArray(fills) ? fills : []).map(f => ({
        time: f.time, coin: f.coin, sz: parseFloat(f.sz || 0), px: parseFloat(f.px || 0),
        dir: f.dir, closedPnl: parseFloat(f.closedPnl || 0), fee: parseFloat(f.fee || 0),
      })).sort((a, b) => a.time - b.time);

      const currentPositions = {};
      for (const ap of (account?.assetPositions || [])) {
        const coin = ap.position.coin;
        const szi = parseFloat(ap.position.szi);
        if (szi !== 0) currentPositions[coin] = { size: szi, entryPx: parseFloat(ap.position.entryPx) };
      }
      const posAtStart = {};
      for (const coin in currentPositions) posAtStart[coin] = { ...currentPositions[coin] };
      for (let i = sortedFills.length - 1; i >= 0; i--) {
        const f = sortedFills[i];
        const coin = f.coin;
        const fillSize = f.dir.includes('Long') || f.dir.includes('Buy')
          ? (f.dir.startsWith('Open') || f.dir.startsWith('Buy') ? f.sz : -f.sz)
          : (f.dir.startsWith('Open') || f.dir.startsWith('Sell') ? -f.sz : f.sz);
        if (!posAtStart[coin]) posAtStart[coin] = { size: 0, entryPx: f.px };
        posAtStart[coin].size -= fillSize;
        if (Math.abs(posAtStart[coin].size) < 1e-10) delete posAtStart[coin];
      }

      const coins = new Set();
      for (const coin in posAtStart) coins.add(coin);
      for (const f of sortedFills) coins.add(f.coin);

      const candleMap = {};
      if (coins.size > 0) {
        await Promise.all([...coins].map(async (coin) => {
          try {
            const candles = await hlPost('candleSnapshot', {
              req: { coin, interval: '30m', startTime: start, endTime: now },
            });
            candleMap[coin] = (candles || []).reduce((m, c) => { m[c.t] = parseFloat(c.c); return m; }, {});
          } catch { candleMap[coin] = {}; }
        }));
      }

      const slotStart = Math.ceil(start / INTERVAL_30M) * INTERVAL_30M;
      const slots = [];
      for (let t = slotStart; t <= now; t += INTERVAL_30M) slots.push(t);

      let fillIdx = 0, realizedPnl = 0;
      const positions = {};
      for (const coin in posAtStart) positions[coin] = { ...posAtStart[coin] };
      const points = [];

      for (const slotTime of slots) {
        while (fillIdx < sortedFills.length && sortedFills[fillIdx].time <= slotTime) {
          const f = sortedFills[fillIdx];
          realizedPnl += f.closedPnl - f.fee;
          const coin = f.coin;
          const fillSize = f.dir.includes('Long') || f.dir.includes('Buy')
            ? (f.dir.startsWith('Open') || f.dir.startsWith('Buy') ? f.sz : -f.sz)
            : (f.dir.startsWith('Open') || f.dir.startsWith('Sell') ? -f.sz : f.sz);
          if (!positions[coin]) positions[coin] = { size: 0, entryPx: f.px };
          positions[coin].size += fillSize;
          if (f.dir.startsWith('Open')) positions[coin].entryPx = f.px;
          if (Math.abs(positions[coin].size) < 1e-10) delete positions[coin];
          fillIdx++;
        }
        let unrealizedPnl = 0;
        for (const coin in positions) {
          const pos = positions[coin];
          const candles = candleMap[coin] || {};
          const candleSlot = Math.floor(slotTime / INTERVAL_30M) * INTERVAL_30M;
          const price = candles[candleSlot];
          if (price && pos.entryPx) unrealizedPnl += (price - pos.entryPx) * pos.size;
        }
        points.push({ time: slotTime, value: realizedPnl + unrealizedPnl });
      }

      const liveUnrealized = (account?.assetPositions || []).reduce((sum, p) => {
        return sum + parseFloat(p?.position?.unrealizedPnl || 0);
      }, 0);
      points.push({ time: now, value: realizedPnl + liveUnrealized });
      return { points, realizedPnl, unrealizedPnl: liveUnrealized };
    }

    async function apiPortfolio(range) {
      range = (range || '7d').toLowerCase();
      const account = await hlPost('clearinghouseState', { user: WALLET });
      const accountValue = parseFloat(account?.marginSummary?.accountValue || 0);
      const liveUnrealized = (account?.assetPositions || []).reduce((sum, p) => {
        return sum + parseFloat(p?.position?.unrealizedPnl || 0);
      }, 0);
      let points, realizedPnl = 0, unrealizedPnl = 0;

      if (range === '1d') {
        const result = await build1dPnl(account);
        points = result.points; realizedPnl = result.realizedPnl; unrealizedPnl = result.unrealizedPnl;
      } else {
        const periodKey = RANGE_TO_PERIOD[range] || 'perpWeek';
        const portfolio = await hlPost('portfolio', { user: WALLET });
        let periodData = null;
        if (Array.isArray(portfolio)) {
          for (const [name, data] of portfolio) { if (name === periodKey) { periodData = data; break; } }
        }
        const pnlHistory = periodData?.pnlHistory || [];
        points = pnlHistory.map(([ts, pnl]) => ({ time: ts, value: parseFloat(pnl) }));
        if (points.length > 0) {
          const totalPnl = points[points.length - 1].value;
          unrealizedPnl = liveUnrealized;
          realizedPnl = totalPnl - unrealizedPnl;
        }
      }

      if (!points || points.length === 0) {
        return { points: [{ time: Date.now(), value: 0 }], currentPnl: 0, pnlAmount: 0,
          pnlPercent: 0, realizedPnl: 0, unrealizedPnl: 0, range };
      }

      const startPnl = points[0].value;
      const endPnl = points[points.length - 1].value;
      const pnlAmount = endPnl - startPnl;
      const pnlPercent = accountValue > 0 ? (pnlAmount / accountValue) * 100 : 0;
      return { points, currentPnl: endPnl, pnlAmount, pnlPercent, realizedPnl, unrealizedPnl, range };
    }

    // ---- apiDecisions ----
    // Fetch bot decisions + config from synced JSON (cached 60s)
    let _botCache = { decisions: [], config: null, ts: 0 };
    async function fetchBotDecisions() {
      if (Date.now() - _botCache.ts < 60000) return _botCache.decisions;
      try {
        const res = await fetch('./data/decisions.json?t=' + Math.floor(Date.now() / 60000));
        if (!res.ok) return _botCache.decisions;
        const raw = await res.json();
        // Support both formats: array (old) or {decisions, config} (new)
        if (Array.isArray(raw)) {
          _botCache = { decisions: raw, config: null, ts: Date.now() };
        } else {
          _botCache = { decisions: raw.decisions || [], config: raw.config || null, ts: Date.now() };
          // Update config from bot if available
          if (raw.config?.entryThreshold) window._botConfig = raw.config;
        }
        return _botCache.decisions;
      } catch { return _botCache.decisions; }
    }

    // Shared whale cache â€” populated by apiData, reused by apiDecisions
    let _whaleCache = { accounts: [], btcLong: 0, btcShort: 0, ethLong: 0, ethShort: 0, byCoin: {}, ts: 0 };

    // Whale fills cache â€” fetched independently every 2min
    let _whaleFillsCache = { trades: [], ts: 0 };
    const whaleNameMap = {};
    WATCHED_WHALES.forEach((addr, i) => whaleNameMap[addr] = `Whale ${i + 1}`);

    async function fetchWhaleFills() {
      if (Date.now() - _whaleFillsCache.ts < 120000) return; // 2min cache (Allium â€” no rate limit)
      try {
        const dayAgo = Date.now() - 24 * 60 * 60 * 1000;
        // Fetch 3 whales at a time to avoid rate limits
        const raw = [];
        for (let i = 0; i < WATCHED_WHALES.length; i += 3) {
          const batch = WATCHED_WHALES.slice(i, i + 3);
          const results = await Promise.all(
            batch.map(addr =>
              alliumFills({ type: 'userFills', user: addr }).then(fills => {
                if (!Array.isArray(fills)) return [];
                // Allium returns newest first (up to 2000) â€” take first 10 within 24h
                return fills
                  .slice(0, 50)
                  .filter(f => (typeof f.time === 'number' ? f.time : new Date(f.time).getTime()) > dayAgo)
                  .slice(0, 10)
                  .map(f => ({ ...f, _whale: addr }));
              }).catch(() => [])
            )
          );
          for (const r of results) raw.push(...r);
          if (i + 3 < WATCHED_WHALES.length) await new Promise(r => setTimeout(r, 100)); // Allium: fast
        }
        _whaleFillsCache = {
          trades: raw
            .map(f => ({
              time: typeof f.time === 'number' ? f.time : new Date(f.time).getTime(),
              coin: f.coin,
              direction: f.side === 'B' ? 'LONG' : 'SHORT',
              size: parseFloat(f.sz), price: parseFloat(f.px),
              value: Math.abs(parseFloat(f.sz) * parseFloat(f.px)),
              whale: whaleNameMap[f._whale] || f._whale?.slice(0,6),
            }))
            .filter(t => t.value >= 50)
            .sort((a, b) => b.time - a.time)
            .slice(0, 30),
          ts: Date.now(),
        };
        // Re-render trades table with fresh data
        if (_whaleFillsCache.trades.length > 0) {
          renderTrades(_whaleFillsCache.trades);
        }
      } catch(e) { console.error('Whale fills error:', e); }
    }

    async function fetchWhaleData() {
      if (Date.now() - _whaleCache.ts < 45000 && _whaleCache.accounts.length > 0) return _whaleCache;
      // Allium for whale positions â€” no rate limit!
      const whaleAccounts = await Promise.all(
        WATCHED_WHALES.map(addr =>
          alliumInfo({ type: 'clearinghouseState', user: addr }).catch(() => ({ assetPositions: [] }))
        )
      );
      const byCoin = {};
      let btcLong = 0, btcShort = 0, ethLong = 0, ethShort = 0;
      for (const wa of whaleAccounts) {
        for (const p of (wa?.assetPositions || [])) {
          const coin = p.position.coin;
          const size = parseFloat(p.position.szi);
          if (size === 0) continue;
          if (!byCoin[coin]) byCoin[coin] = { long: 0, short: 0 };
          if (size > 0) byCoin[coin].long++; else byCoin[coin].short++;
          if (coin === 'BTC') { if (size > 0) btcLong++; else btcShort++; }
          if (coin === 'ETH') { if (size > 0) ethLong++; else ethShort++; }
        }
      }
      _whaleCache = { accounts: whaleAccounts, btcLong, btcShort, ethLong, ethShort, byCoin, ts: Date.now() };
      return _whaleCache;
    }

    async function apiDecisions() {
      // Fetch account + prices + fills + bot decisions (whales from shared cache)
      const [rawAccount, rawPrices, rawFills, botDecisions] = await Promise.all([
        hlFetch({ type: 'clearinghouseState', user: WALLET }).catch(() => null),
        hlFetch({ type: 'allMids' }).catch(() => ({})),
        hlFetch({ type: 'userFills', user: WALLET }).catch(() => []),
        fetchBotDecisions(),
      ]);
      const whaleData = await fetchWhaleData(); // uses cache from apiData

      const account = rawAccount || { marginSummary: { accountValue: '0' }, assetPositions: [] };
      const prices = rawPrices || {};
      const fills = Array.isArray(rawFills) ? rawFills : [];

      const accountValue = parseFloat(account.marginSummary?.accountValue || 0);
      const positions = (account.assetPositions || []).filter(p => parseFloat(p.position.szi) !== 0).map(p => ({
        coin: p.position.coin, direction: parseFloat(p.position.szi) > 0 ? 'LONG' : 'SHORT',
        size: Math.abs(parseFloat(p.position.szi)), entryPrice: parseFloat(p.position.entryPx),
        pnl: parseFloat(p.position.unrealizedPnl || 0), leverage: parseFloat(p.position.leverage?.value || 1),
      }));

      // Whale data from shared cache (no duplicate API calls)
      const whalesByCoin = whaleData.byCoin;
      const { btcLong, btcShort, ethLong, ethShort } = whaleData;

      const btcPrice = parseFloat(prices.BTC || 0);
      const ethPrice = parseFloat(prices.ETH || 0);

      // --- Build history from actual fills ---
      const now = Date.now();
      const cutoff = now - 7 * 24 * 60 * 60 * 1000; // 7 days
      const history = [];

      // Group fills into trades
      function groupFills(rawFills) {
        const trades = [];
        let cur = null;
        for (const f of rawFills) {
          const t = f.time, coin = f.coin, dir = f.dir;
          if (cur && cur.coin === coin && Math.abs(t - cur.time) < 10000 && cur.dir === dir) {
            cur.totalSize += parseFloat(f.sz);
            cur.totalValue += parseFloat(f.sz) * parseFloat(f.px);
            cur.totalPnl += parseFloat(f.closedPnl);
            cur.fills++;
          } else {
            if (cur) trades.push(cur);
            cur = { coin, dir, time: t, px: parseFloat(f.px), totalSize: parseFloat(f.sz),
              totalValue: parseFloat(f.sz) * parseFloat(f.px), totalPnl: parseFloat(f.closedPnl), fills: 1 };
          }
        }
        if (cur) trades.push(cur);
        return trades;
      }

      const trades = groupFills(fills.filter(f => f.time > cutoff));

      // Convert trades to history events
      let totalRealizedPnl = 0;
      let wins = 0, closedCount = 0;
      for (const t of trades) {
        const avgPx = t.totalSize > 0 ? t.totalValue / t.totalSize : t.px;
        const pxFmt = avgPx > 100 ? `$${avgPx.toLocaleString('en-US', {maximumFractionDigits:1})}` : `$${avgPx.toPrecision(4)}`;
        const pnlStr = t.totalPnl >= 0 ? `+$${t.totalPnl.toFixed(2)}` : `-$${Math.abs(t.totalPnl).toFixed(2)}`;
        let type, action, reason;

        if (t.dir.startsWith('Open Long')) {
          type = 'ENTRY'; action = `LONG ${t.coin} ì§„ì…`;
          reason = `${t.coin} LONG â€” ${t.totalSize.toPrecision(4)} @ ${pxFmt}`;
        } else if (t.dir.startsWith('Open Short')) {
          type = 'ENTRY'; action = `SHORT ${t.coin} ì§„ì…`;
          reason = `${t.coin} SHORT â€” ${t.totalSize.toPrecision(4)} @ ${pxFmt}`;
        } else if (t.dir.startsWith('Close Long')) {
          type = 'EXIT'; action = `LONG ${t.coin} ì¢…ë£Œ`;
          reason = `${t.coin} LONG ì¢…ë£Œ â€” ${pnlStr} (${t.totalPnl >= 0 ? 'ìµì ˆ' : 'ì†ì ˆ'}) @ ${pxFmt}`;
          totalRealizedPnl += t.totalPnl; closedCount++; if (t.totalPnl > 0) wins++;
        } else if (t.dir.startsWith('Close Short')) {
          type = 'EXIT'; action = `SHORT ${t.coin} ì¢…ë£Œ`;
          reason = `${t.coin} SHORT ì¢…ë£Œ â€” ${pnlStr} (${t.totalPnl >= 0 ? 'ìµì ˆ' : 'ì†ì ˆ'}) @ ${pxFmt}`;
          totalRealizedPnl += t.totalPnl; closedCount++; if (t.totalPnl > 0) wins++;
        } else if (t.dir.includes('>')) {
          type = 'FLIP'; const newDir = t.dir.includes('> Short') ? 'SHORT' : 'LONG';
          action = `${t.coin} â†’ ${newDir} ì „í™˜`;
          reason = `${t.coin} ë°©í–¥ ì „í™˜ (${pnlStr}) @ ${pxFmt}`;
          totalRealizedPnl += t.totalPnl; closedCount++; if (t.totalPnl > 0) wins++;
        } else {
          type = 'TRADE'; action = `${t.coin} ${t.dir}`;
          reason = `${t.totalSize.toPrecision(4)} @ ${pxFmt}`;
        }

        history.push({ timestamp: new Date(t.time).toISOString(), time: t.time, type, action, reason });
      }

      // Merge bot decisions (SKIP, PERIODIC, TRADE from algorithm)
      const botCutoff = now - 48 * 60 * 60 * 1000;
      for (const bd of botDecisions) {
        const bdTime = new Date(bd.timestamp).getTime();
        if (bdTime < botCutoff) continue;

        if (bd.type === 'PERIODIC') {
          // Bot's periodic analysis summary â€” shows actual signal scores
          const btcSig = bd.signals?.BTC;
          const ethSig = bd.signals?.ETH;
          const btcStr = btcSig ? `BTC ${btcSig.direction}(${btcSig.score})` : '';
          const ethStr = ethSig ? `ETH ${ethSig.direction}(${ethSig.score})` : '';
          history.push({
            timestamp: bd.timestamp, time: bdTime, type: 'PERIODIC',
            action: bd.action || 'ë¶„ì„ ì™„ë£Œ',
            reason: `${bd.reason || ''}${btcStr || ethStr ? ` [${btcStr} ${ethStr}]` : ''}`,
          });
        } else if (bd.type === 'SKIP' && bd.signal) {
          // Show significant SKIP decisions (score > 20 = was close to entry)
          if (Math.abs(bd.signal.score || 0) > 20) {
            history.push({
              timestamp: bd.timestamp, time: bdTime, type: 'SKIP',
              action: bd.action || `SKIP`,
              reason: `ìŠ¤ì½”ì–´ ${bd.signal.score} (ì‹ ë¢°ë„ ${((bd.signal.confidence || 0) * 100).toFixed(0)}%) â€” ${bd.reason || 'ê¸°ì¤€ ë¯¸ë‹¬'}`,
            });
          }
        } else if (bd.type === 'TRADE') {
          // Bot's trade decisions (may overlap with fills â€” dedup by checking time proximity)
          const hasMatchingFill = history.some(h => h.type === 'ENTRY' || h.type === 'EXIT' ? Math.abs(h.time - bdTime) < 60000 : false);
          if (!hasMatchingFill) {
            history.push({
              timestamp: bd.timestamp, time: bdTime, type: bd.action?.includes('CLOSE') ? 'EXIT' : 'ENTRY',
              action: bd.action || 'TRADE', reason: bd.reason || '',
            });
          }
        }
      }

      // Sort newest first
      history.sort((a, b) => b.time - a.time);

      // Insert periodic gaps (every 3h between events, and from now to most recent)
      const PERIODIC_GAP = 3 * 60 * 60 * 1000;
      const withPeriodic = [];

      // Current state as first entry
      const btcWhaleDir = btcShort > btcLong ? 'SHORT' : (btcLong > btcShort ? 'LONG' : 'MIXED');
      const ethWhaleDir = ethShort > ethLong ? 'SHORT' : (ethLong > ethShort ? 'LONG' : 'MIXED');

      if (positions.length > 0) {
        const posLines = positions.map(p => {
          const pnlPct = (p.pnl / accountValue * 100).toFixed(1);
          return `${p.direction} ${p.coin} â€” $${p.pnl.toFixed(2)} (${pnlPct}%)`;
        }).join(', ');
        withPeriodic.push({ timestamp: new Date(now).toISOString(), time: now, type: 'CURRENT',
          action: `${positions.length}ê°œ í¬ì§€ì…˜ ë³´ìœ `, reason: posLines });
      } else {
        withPeriodic.push({ timestamp: new Date(now).toISOString(), time: now, type: 'CURRENT',
          action: 'í¬ì§€ì…˜ ì—†ìŒ - ê´€ë§',
          reason: `ì‹œê·¸ë„ ê¸°ì¤€ ë¯¸ë‹¬. ê´€ë§ ëŒ€ê¸° ì¤‘.` });
      }

      // Add actual trade events and periodic fillers
      let lastTime = now;
      for (const h of history) {
        // Insert periodic if gap > 3h
        if (lastTime - h.time > PERIODIC_GAP) {
          const periodicTime = h.time + PERIODIC_GAP;
          withPeriodic.push({ timestamp: new Date(periodicTime).toISOString(), time: periodicTime, type: 'PERIODIC',
            action: 'ê´€ë§ ìœ ì§€', reason: `BTC/ETH ì‹œê·¸ë„ ê¸°ì¤€ ë¯¸ë‹¬. ê³ ë˜: BTC ${btcWhaleDir} (${btcLong}L/${btcShort}S), ETH ${ethWhaleDir} (${ethLong}L/${ethShort}S).` });
        }
        withPeriodic.push(h);
        lastTime = h.time;
      }

      // If no trade events at all, add periodic entries
      if (history.length === 0) {
        for (let t = now - PERIODIC_GAP; t > now - 24*60*60*1000; t -= PERIODIC_GAP) {
          withPeriodic.push({ timestamp: new Date(t).toISOString(), time: t, type: 'PERIODIC',
            action: 'ê´€ë§ ìœ ì§€', reason: `BTC/ETH ì‹œê·¸ë„ ê¸°ì¤€ ë¯¸ë‹¬. ê³ ë˜: BTC ${btcWhaleDir} (${btcLong}L/${btcShort}S), ETH ${ethWhaleDir} (${ethLong}L/${ethShort}S).` });
        }
        // System start
        withPeriodic.push({ timestamp: new Date(now - 24*60*60*1000).toISOString(), time: now - 24*60*60*1000,
          type: 'SYSTEM', action: 'ì‹œìŠ¤í…œ ì‹œì‘', reason: `Hyperliquid ì—°ê²° ì™„ë£Œ. ê³„ì¢Œ ì”ê³  $${accountValue.toFixed(0)}.` });
      }

      // Current decision card
      let currentDecision;
      if (positions.length > 0) {
        const pos = positions[0];
        const pnlPercent = (pos.pnl / accountValue * 100).toFixed(1);
        currentDecision = { status: 'IN_POSITION', action: `${pos.direction} ${pos.coin}`,
          reason: `ì‹œê·¸ë„ ê¸°ë°˜ ì§„ì…. PnL: $${pos.pnl.toFixed(2)} (${pnlPercent}%). TP/SL ìë™ ì„¤ì •.`,
          emoji: pos.pnl >= 0 ? 'ğŸ“ˆ' : 'ğŸ“‰' };
      } else {
        // Use latest bot PERIODIC decision for real signal scores
        const latestPeriodic = botDecisions.filter(d => d.type === 'PERIODIC').pop();
        const btcSigScore = latestPeriodic?.signals?.BTC?.score || 0;
        const ethSigScore = latestPeriodic?.signals?.ETH?.score || 0;
        const btcSigDir = latestPeriodic?.signals?.BTC?.direction || 'NEUTRAL';
        const ethSigDir = latestPeriodic?.signals?.ETH?.direction || 'NEUTRAL';

        currentDecision = { status: 'WAITING', action: 'í¬ì§€ì…˜ ì—†ìŒ - ê´€ë§',
          reason: `ğŸ¤– ë´‡ ì‹œê·¸ë„: BTC ${btcSigDir}(${btcSigScore}) / ETH ${ethSigDir}(${ethSigScore})\n\nğŸ‹ ê³ ë˜ ë™í–¥: BTC ${btcWhaleDir} (${btcLong}L/${btcShort}S), ETH ${ethWhaleDir} (${ethLong}L/${ethShort}S).\n\nğŸ’° í˜„ì¬ê°€: BTC $${btcPrice.toLocaleString()}, ETH $${ethPrice.toLocaleString()}.\n\nâ³ ì§„ì… ê¸°ì¤€: ì‹œê·¸ë„ ìŠ¤ì½”ì–´ Â±${config_entryThreshold()} ì´ìƒ í•„ìš”.`,
          emoji: 'â³' };
      }

      const btcWhaleScore = Math.max(btcLong, btcShort) / (btcLong + btcShort || 1) * 100;
      const ethWhaleScore = Math.max(ethLong, ethShort) / (ethLong + ethShort || 1) * 100;

      // BTC/ETH ìŠ¤ì½”ì–´: ë´‡ ì‹œê·¸ë„ ìŠ¤ì½”ì–´ + ê³ ë˜ ì»¨ì„¼ì„œìŠ¤ í˜¼í•©
      const latestBotPeriodic = botDecisions.filter(d => d.type === 'PERIODIC').pop();
      const botBtcScore = latestBotPeriodic?.signals?.BTC?.score;
      const botEthScore = latestBotPeriodic?.signals?.ETH?.score;
      // ë´‡ ì‹œê·¸ë„ì´ ìˆìœ¼ë©´ ì‚¬ìš©, ì—†ìœ¼ë©´ ê³ ë˜ ìŠ¤ì½”ì–´ fallback
      currentDecision.btcScore = botBtcScore != null ? Math.abs(Math.round(botBtcScore)) : Math.round(btcWhaleScore);
      currentDecision.ethScore = botEthScore != null ? Math.abs(Math.round(botEthScore)) : Math.round(ethWhaleScore);
      currentDecision.btcWhale = `${btcLong}L/${btcShort}S`;
      currentDecision.ethWhale = `${ethLong}L/${ethShort}S`;

      return {
        current: currentDecision,
        history: withPeriodic.slice(0, 20),
        lastUpdate: new Date(now).toISOString(),
        nextUpdate: new Date(now + 2 * 60 * 60 * 1000).toISOString(),
        stats: {
          accountValue,
          totalTrades: trades.length,
          winRate: closedCount > 0 ? `${wins}/${closedCount}` : 'N/A',
          totalPnL: totalRealizedPnl,
        },
      };
    }

    // ============================================================
    // INIT (after all API functions are defined)
    // ============================================================
    fetchData();
    fetchDecision();
    fetchPortfolio(currentRange);
    setTimeout(fetchWhaleFills, 2000); // Initial whale fills (2s delay to avoid burst with fetchData)
    setInterval(fetchData, 30000);
    setInterval(fetchDecision, 60000);
    setInterval(() => fetchPortfolio(currentRange), 60000);
    setInterval(fetchWhaleFills, 120000);

    // ============================================================
    // PAGE TABS
    // ============================================================
    function switchPage(page) {
      document.querySelectorAll('.page-tab').forEach(t => t.classList.remove('active'));
      document.querySelector(`.page-tab[onclick*="${page}"]`).classList.add('active');
      ['trading', 'analytics', 'algorithm'].forEach(p => {
        const el = document.getElementById(p + '-page');
        if (el) el.style.display = p === page ? 'block' : 'none';
      });
      if (page === 'analytics' && !window._analyticsLoaded) loadAnalytics();
    }
    window.switchPage = switchPage;

    // ============================================================
    // ANALYTICS TAB
    // ============================================================
    let consensusChart = null;

    async function loadAnalytics() {
      try {
        const res = await fetch('./data/whale-analytics.json?t=' + Date.now());
        if (!res.ok) return;
        const data = await res.json();
        window._analyticsLoaded = true;

        // Stats
        document.getElementById('a-total-trades').textContent = (data.stats.totalTrades || 0).toLocaleString();
        document.getElementById('a-round-trips').textContent = (data.stats.totalRoundTrips || 0).toLocaleString();
        document.getElementById('a-avg-wr').textContent = (data.stats.avgWinRate || 0) + '%';
        document.getElementById('a-whale-count').textContent = data.stats.profileCount || 0;

        // Profiles
        renderProfiles(data.profiles || []);
        // Weight sliders
        renderWeightSliders(data.profiles || []);
        // Consensus chart
        renderConsensus(data.consensus || []);
        // Heatmap
        renderHeatmap(data.heatmap || []);
      } catch(e) { console.error('Analytics load error:', e); }
    }

    function renderProfiles(profiles) {
      const grid = document.getElementById('profile-grid');
      grid.innerHTML = profiles.map((p, i) => {
        const wr = ((p.win_rate || 0) * 100).toFixed(1);
        const wrColor = p.win_rate > 0.5 ? 'var(--green)' : 'var(--red)';
        const style = p.trading_style === 'day_trader' ? 'âš¡ Day' : p.trading_style === 'swing_trader' ? 'ğŸŒŠ Swing' : 'ğŸ“Š ' + (p.trading_style || '?');
        const pnlSign = (p.total_pnl || 0) >= 0 ? '+' : '';
        const pnlColor = (p.total_pnl || 0) >= 0 ? 'var(--green)' : 'var(--red)';
        const topAssets = (p.top_assets || []).map(a => `${a.coin}(${a.trades})`).join(', ') || '-';
        const skillBg = p.skill_weight > 1.2 ? 'var(--green)' : p.skill_weight > 0.9 ? '#f59e0b' : 'var(--red)';
        return `
          <div class="profile-card">
            <div class="profile-header">
              <span class="profile-name">ğŸ‹ Whale ${i + 1}</span>
              <span class="profile-badge" style="background:${skillBg};color:#000">${style}</span>
            </div>
            <div class="profile-stat"><span class="label">Address</span><span class="value" style="font-family:monospace;font-size:11px">${p.address}</span></div>
            <div class="profile-stat"><span class="label">Win Rate</span><span class="value" style="color:${wrColor}">${wr}%</span></div>
            <div class="profile-stat"><span class="label">Round Trips</span><span class="value">${p.total_round_trips || 0}</span></div>
            <div class="profile-stat"><span class="label">Total PnL</span><span class="value" style="color:${pnlColor}">${pnlSign}$${(p.total_pnl || 0).toFixed(2)}</span></div>
            <div class="profile-stat"><span class="label">Profit Factor</span><span class="value">${(p.profit_factor || 0).toFixed(2)}</span></div>
            <div class="profile-stat"><span class="label">Avg Hold</span><span class="value">${p.hold_time_hours || 0}h</span></div>
            <div class="profile-stat"><span class="label">Bias</span><span class="value">${((p.long_bias || 0) * 100).toFixed(0)}% Long</span></div>
            <div class="profile-stat"><span class="label">Top Assets</span><span class="value" style="font-size:11px">${topAssets}</span></div>
            <div class="profile-stat"><span class="label">Skill Weight</span><span class="value" style="color:${skillBg}">${(p.skill_weight || 1).toFixed(2)}x</span></div>
          </div>`;
      }).join('');
    }

    function renderConsensus(data) {
      if (!data.length) return;
      const ctx = document.getElementById('consensus-chart').getContext('2d');
      if (consensusChart) consensusChart.destroy();

      const labels = data.map(d => d.time);
      consensusChart = new Chart(ctx, {
        type: 'line',
        data: {
          labels,
          datasets: [
            {
              label: 'BTC Long', data: data.map(d => d.btc.long),
              borderColor: '#22c55e', backgroundColor: 'rgba(34,197,94,0.1)',
              fill: true, tension: 0.3, borderWidth: 2, pointRadius: 0,
            },
            {
              label: 'BTC Short', data: data.map(d => -d.btc.short),
              borderColor: '#ef4444', backgroundColor: 'rgba(239,68,68,0.1)',
              fill: true, tension: 0.3, borderWidth: 2, pointRadius: 0,
            },
            {
              label: 'ETH Long', data: data.map(d => d.eth.long),
              borderColor: '#3b82f6', borderDash: [5, 3],
              tension: 0.3, borderWidth: 1.5, pointRadius: 0,
            },
            {
              label: 'ETH Short', data: data.map(d => -d.eth.short),
              borderColor: '#f97316', borderDash: [5, 3],
              tension: 0.3, borderWidth: 1.5, pointRadius: 0,
            },
          ],
        },
        options: {
          responsive: true,
          interaction: { mode: 'index', intersect: false },
          scales: {
            x: {
              type: 'time', time: { unit: 'hour', displayFormats: { hour: 'M/d HH:mm' } },
              grid: { color: 'rgba(255,255,255,0.05)' }, ticks: { color: '#888', maxTicksLimit: 12 },
            },
            y: {
              grid: { color: 'rgba(255,255,255,0.05)' }, ticks: { color: '#888' },
              title: { display: true, text: 'Long â†‘ / Short â†“', color: '#888' },
            },
          },
          plugins: { legend: { labels: { color: '#ccc', font: { size: 11 } } } },
        },
      });
    }

    function renderHeatmap(data) {
      const container = document.getElementById('heatmap-container');
      if (!data.length) { container.innerHTML = '<p style="color:var(--muted)">No data</p>'; return; }

      const maxVal = Math.max(...data.flatMap(d => d.hours));
      const hours = Array.from({length: 24}, (_, i) => `${String(i).padStart(2, '0')}`);

      let html = '<table style="border-collapse:collapse;width:100%"><thead><tr><th style="text-align:left;color:var(--muted);font-size:11px;padding:4px">Coin</th>';
      hours.forEach(h => html += `<th style="color:var(--muted);font-size:10px;padding:2px">${h}</th>`);
      html += '<th style="color:var(--muted);font-size:10px;padding:4px">Total</th></tr></thead><tbody>';

      for (const d of data) {
        html += `<tr><td style="font-weight:600;font-size:12px;padding:4px">${d.coin}</td>`;
        d.hours.forEach(v => {
          const intensity = maxVal > 0 ? v / maxVal : 0;
          const bg = intensity > 0.7 ? 'rgba(34,197,94,0.8)' : intensity > 0.4 ? 'rgba(34,197,94,0.4)' : intensity > 0.1 ? 'rgba(34,197,94,0.15)' : 'transparent';
          html += `<td style="text-align:center"><span class="heatmap-cell" style="background:${bg}">${v || ''}</span></td>`;
        });
        html += `<td style="text-align:center;font-weight:600;font-size:12px">${d.total}</td></tr>`;
      }
      html += '</tbody></table>';
      container.innerHTML = html;
    }

    // ============================================================
    // WHALE WEIGHT ADJUSTMENT
    // ============================================================
    let _analyticsProfiles = [];
    const WEIGHT_STORAGE_KEY = 'kuro_whale_weights';

    function loadSavedWeights() {
      try { return JSON.parse(localStorage.getItem(WEIGHT_STORAGE_KEY) || '{}'); } catch { return {}; }
    }

    function renderWeightSliders(profiles) {
      _analyticsProfiles = profiles;
      const saved = loadSavedWeights();
      const container = document.getElementById('weight-sliders');

      container.innerHTML = profiles.map((p, i) => {
        const addr = p.address;
        const savedW = saved[addr]?.weight;
        const defaultW = (p.skill_weight || 1.0);
        const currentW = savedW ?? defaultW;
        const enabled = saved[addr]?.enabled !== false;
        const wr = ((p.win_rate || 0) * 100).toFixed(0);
        const cls = currentW > 1.05 ? 'boosted' : currentW < 0.95 ? 'nerfed' : 'neutral';

        return `
          <div class="weight-row">
            <button class="weight-toggle ${enabled ? '' : 'disabled'}" onclick="toggleWhaleEnabled(${i})" title="Enable/Disable">
              ${enabled ? 'âœ…' : 'â›”'}
            </button>
            <div class="weight-label">ğŸ‹ Whale ${i + 1} <span style="font-size:10px;color:var(--muted);font-family:monospace">${addr}</span></div>
            <div class="weight-meta">WR ${wr}% Â· PF ${(p.profit_factor || 0).toFixed(1)}</div>
            <input type="range" class="weight-slider" min="0" max="200" value="${Math.round(currentW * 100)}"
              oninput="updateWeight(${i}, this.value)" ${!enabled ? 'disabled' : ''}>
            <div class="weight-value ${cls}" id="wv-${i}">${currentW.toFixed(2)}x</div>
          </div>`;
      }).join('');
    }

    function updateWeight(idx, val) {
      const w = val / 100;
      const el = document.getElementById(`wv-${idx}`);
      el.textContent = w.toFixed(2) + 'x';
      el.className = 'weight-value ' + (w > 1.05 ? 'boosted' : w < 0.95 ? 'nerfed' : 'neutral');

      // Save to localStorage
      const saved = loadSavedWeights();
      const addr = _analyticsProfiles[idx].address;
      saved[addr] = { ...saved[addr], weight: w };
      localStorage.setItem(WEIGHT_STORAGE_KEY, JSON.stringify(saved));
    }
    window.updateWeight = updateWeight;

    function toggleWhaleEnabled(idx) {
      const saved = loadSavedWeights();
      const addr = _analyticsProfiles[idx].address;
      const current = saved[addr]?.enabled !== false;
      saved[addr] = { ...saved[addr], enabled: !current, weight: saved[addr]?.weight ?? _analyticsProfiles[idx].skill_weight ?? 1.0 };
      localStorage.setItem(WEIGHT_STORAGE_KEY, JSON.stringify(saved));
      renderWeightSliders(_analyticsProfiles); // re-render
    }
    window.toggleWhaleEnabled = toggleWhaleEnabled;

    function resetWeights() {
      localStorage.removeItem(WEIGHT_STORAGE_KEY);
      renderWeightSliders(_analyticsProfiles);
      document.getElementById('weight-status').textContent = 'âœ… Reset to computed defaults';
    }
    window.resetWeights = resetWeights;

    async function applyWeights() {
      const saved = loadSavedWeights();
      if (Object.keys(saved).length === 0) {
        document.getElementById('weight-status').textContent = 'âš ï¸ No changes to apply';
        return;
      }

      const statusEl = document.getElementById('weight-status');
      statusEl.textContent = 'â³ Applying...';

      // Write to GitHub repo via API (data/whale-overrides.json)
      try {
        const content = btoa(unescape(encodeURIComponent(JSON.stringify(saved, null, 2))));
        const repo = 'lukealwaysawake/kuro-dashboard-static';
        const path = 'data/whale-overrides.json';
        const token = localStorage.getItem('github_token');

        if (!token) {
          // Fallback: copy to clipboard for manual apply
          const json = JSON.stringify(saved, null, 2);
          await navigator.clipboard.writeText(json);
          statusEl.innerHTML = 'ğŸ“‹ Copied to clipboard! Send to Kuro to apply.<br><code style="font-size:10px">' +
            JSON.stringify(saved).slice(0, 80) + '...</code>';
          return;
        }

        // Get current file SHA
        const existing = await fetch(`https://api.github.com/repos/${repo}/contents/${path}`, {
          headers: { Authorization: `token ${token}` }
        }).then(r => r.ok ? r.json() : null).catch(() => null);

        await fetch(`https://api.github.com/repos/${repo}/contents/${path}`, {
          method: 'PUT',
          headers: { Authorization: `token ${token}`, 'Content-Type': 'application/json' },
          body: JSON.stringify({
            message: 'Update whale weight overrides from dashboard UI',
            content,
            sha: existing?.sha,
          })
        });

        statusEl.textContent = 'âœ… Applied! Bot will pick up changes within 5 minutes.';
      } catch(e) {
        const json = JSON.stringify(saved, null, 2);
        await navigator.clipboard.writeText(json).catch(() => {});
        statusEl.innerHTML = `âš ï¸ GitHub push failed. Config copied to clipboard.<br><small>${e.message}</small>`;
      }
    }
    window.applyWeights = applyWeights;

    // ============================================================
    // ALGORITHM TAB
    // ============================================================
    (function renderAlgoWeights() {
      const weights = [
        { name: 'Whale Consensus', key: 'whale', w: 0.30, color: '#22c55e', desc: '14 ê³ ë˜ í¬ì§€ì…˜ í•©ì˜' },
        { name: 'Trend (EMA)', key: 'trend', w: 0.15, color: '#3b82f6', desc: 'EMA 20/50/200 ì •ë ¬' },
        { name: 'Momentum', key: 'momentum', w: 0.15, color: '#8b5cf6', desc: 'RSI + MACD + Stochastic' },
        { name: 'Multi-Timeframe', key: 'mtf', w: 0.10, color: '#06b6d4', desc: '1h íŠ¸ë Œë“œ + 15m ëª¨ë©˜í…€ + 5m ì§„ì…' },
        { name: 'Volume', key: 'volume', w: 0.10, color: '#f59e0b', desc: 'ê±°ë˜ëŸ‰ ì´ìƒ + OBV' },
        { name: 'Divergence', key: 'divergence', w: 0.10, color: '#ec4899', desc: 'RSI/MACD ë‹¤ì´ë²„ì „ìŠ¤' },
        { name: 'On-chain', key: 'onchain', w: 0.05, color: '#14b8a6', desc: 'ì˜¨ì²´ì¸ ë©”íŠ¸ë¦­ìŠ¤' },
        { name: 'Orderbook', key: 'orderbook', w: 0.05, color: '#6366f1', desc: 'í˜¸ê°€ì°½ ë¶ˆê· í˜•' },
      ];

      const container = document.getElementById('algo-weight-bars');
      if (!container) return;
      container.innerHTML = weights.map(w => `
        <div class="algo-weight-bar">
          <div class="bar-label">${w.name}</div>
          <div class="bar-bg">
            <div class="bar-fill" style="width:${w.w * 100 * 3.33}%;background:${w.color}">${(w.w * 100).toFixed(0)}%</div>
          </div>
          <div style="width:180px;font-size:11px;color:var(--muted);padding-left:8px">${w.desc}</div>
        </div>`).join('');
    })();

    // Live config from decisions.json
    async function loadAlgoConfig() {
      try {
        const res = await fetch('./data/decisions.json?t=' + Date.now());
        const data = await res.json();
        const cfg = data.config || {};
        const el = document.getElementById('algo-live-config');
        if (!el) return;
        el.innerHTML = `
          <div style="display:grid;grid-template-columns:repeat(auto-fill,minmax(220px,1fr));gap:8px">
            <div style="background:#1a1d23;border-radius:6px;padding:10px">
              <div style="font-weight:600;color:var(--text);margin-bottom:4px">Entry Threshold</div>
              <div style="font-size:18px;font-weight:700;color:var(--green)">${cfg.entryThreshold || 35}</div>
              <div>+ Ranging: +10 | Volatile: +15</div>
            </div>
            <div style="background:#1a1d23;border-radius:6px;padding:10px">
              <div style="font-weight:600;color:var(--text);margin-bottom:4px">Leverage Tiers</div>
              <div>BTC/ETH/SOL: <strong style="color:var(--text)">${cfg.leverageTiers?.BTC || 5}x</strong></div>
              <div>Others: <strong style="color:var(--text)">${cfg.leverageTiers?.default || 2}x</strong></div>
            </div>
            <div style="background:#1a1d23;border-radius:6px;padding:10px">
              <div style="font-weight:600;color:var(--text);margin-bottom:4px">Max Positions</div>
              <div style="font-size:18px;font-weight:700;color:var(--text)">${cfg.maxPairs || 8}</div>
              <div>Same direction: max 6</div>
            </div>
            <div style="background:#1a1d23;border-radius:6px;padding:10px">
              <div style="font-weight:600;color:var(--text);margin-bottom:4px">Decisions Synced</div>
              <div style="font-size:18px;font-weight:700;color:var(--text)">${(data.decisions || []).length}</div>
              <div>Last: ${data.syncedAt ? new Date(data.syncedAt).toLocaleString('ko-KR') : '-'}</div>
            </div>
          </div>`;
      } catch(e) { console.warn('Config load failed:', e); }
    }
    loadAlgoConfig();

    // Hook into loadAnalytics to also render sliders
    const _origLoadAnalytics = loadAnalytics;
    loadAnalytics = async function() {
      await _origLoadAnalytics();
      // Re-render sliders with latest profiles
      if (_analyticsProfiles.length === 0) {
        try {
          const res = await fetch('./data/whale-analytics.json?t=' + Date.now());
          const data = await res.json();
          renderWeightSliders(data.profiles || []);
        } catch {}
      }
    };
  </script>
</body>
</html>
